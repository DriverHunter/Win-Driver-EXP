# Vulnerable Driver AsIO64.sys in ASUS SABERTOOTH X99 Driver v1.0.1.0

---

Many vulnerability exits in driver AsIO64.sys, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port and even read/write arbitary MSR via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

1.0.1.0

## Vulnerability causes

AsIO64.sys  provides the functionality of mapping physical memory and read/write I/O ports and arbitrary read/write MSR, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_119A0(__int64 a1, IRP *a2)//ioctler
{
  BOOLEAN v4; // si
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  NTSTATUS v6; // ebx
  UCHAR MajorFunction; // al
  unsigned int LowPart; // eax
  void *Type; // rdx
  ULONG_PTR v10; // rax
  struct _IRP *MasterIrp; // rbx
  PVOID ContiguousMemory; // rax
  __int64 v14; // [rsp+20h] [rbp-38h]

  v4 = IoIs32bitProcess(a2);
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  v6 = -1073741822;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( !CurrentStackLocation->MajorFunction || MajorFunction == 2 )
  {
LABEL_38:
    v6 = 0;
    goto LABEL_39;
  }
  if ( MajorFunction != 14 )
    goto LABEL_39;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  if ( LowPart > 0xA040A444 )
  {
    switch ( LowPart )
    {
      case 0xA040A448:
        goto LABEL_22;
      case 0xA040A45C:
        v6 = sub_110B0((__int64)a2, (__int64)CurrentStackLocation);// wrmsr
        if ( v6 >= 0 )
          a2->IoStatus.Information = 8i64;
        break;
      case 0xA040A460:
        v6 = sub_11040((__int64)a2, (__int64)CurrentStackLocation);// rdmsr
        if ( v6 >= 0 )
          a2->IoStatus.Information = 8i64;
        break;
      case 0xA040A464:
        v6 = sub_11160(a2);
        if ( v6 >= 0 )
          a2->IoStatus.Information = 4i64;
        break;
      case 0xA040A480:
        goto LABEL_32;
      case 0xA040A488:
        MasterIrp = a2->AssociatedIrp.MasterIrp;
        ContiguousMemory = MmAllocateContiguousMemory(
                             *(unsigned int *)&MasterIrp->Type,
                             (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
        HIDWORD(v14) = (_DWORD)ContiguousMemory;
        LODWORD(v14) = MmGetPhysicalAddress(ContiguousMemory).LowPart;
        *(_QWORD *)&MasterIrp->Type = v14;
        a2->IoStatus.Information = 8i64;
        goto LABEL_38;
      case 0xA040A48C:
        goto LABEL_38;
      default:
        goto LABEL_39;
    }
    goto LABEL_39;
  }
  if ( LowPart == 0xA040A444 )
  {
LABEL_22:
    v6 = sub_11410(a2, CurrentStackLocation, v4);// out primitive
    goto LABEL_39;
  }
  if ( LowPart > 0xA0406404 )
  {
    if ( LowPart == -1606392824 )
      goto LABEL_11;
    if ( LowPart == -1606392744 )
    {
      v6 = sub_11000(a2);
      if ( v6 >= 0 )
        a2->IoStatus.Information = 8i64;
      goto LABEL_39;
    }
    if ( LowPart != -1606376384 )
      goto LABEL_39;
    goto LABEL_22;
  }
  switch ( LowPart )
  {
    case 0xA0406404:
LABEL_11:
      v6 = sub_11260(a2, CurrentStackLocation, v4);// in primitive
      break;
    case 0xA040244C:
LABEL_32:
      v6 = sub_115C0(a1, a2, a2->Tail.Overlay.CurrentStackLocation, v4);// map primitive
      if ( v6 < 0 )
      {
        a2->IoStatus.Status = -1073741811;
      }
      else
      {
        v10 = 8i64;
        if ( v4 )
          v10 = 4i64;
        a2->IoStatus.Information = v10;
      }
      break;
    case 0xA0402450:
      if ( v4 )
      {
        if ( CurrentStackLocation->Parameters.Create.Options >= 4 )
        {
          Type = (void *)a2->AssociatedIrp.MasterIrp->Type;
LABEL_15:
          v6 = ZwUnmapViewOfSection((HANDLE)0xFFFFFFFFFFFFFFFFi64, Type);
          break;
        }
      }
      else if ( CurrentStackLocation->Parameters.Create.Options >= 8 )
      {
        Type = *(void **)a2->AssociatedIrp.MasterIrp;
        goto LABEL_15;
      }
      v6 = -1073741670;
      break;
    case 0xA0406400:
      goto LABEL_11;
  }
LABEL_39:
  a2->IoStatus.Status = v6;
  IofCompleteRequest(a2, 0);
  return (unsigned int)v6;
}
~~~

### IOCTL  0xA040A45C

This IOCTL code triggers the write operation on MSR. 

~~~c
__int64 __fastcall sub_110B0(__int64 a1, __int64 a2)
{
  unsigned int *v3; // rcx
  unsigned int v4; // eax
  unsigned __int64 v5; // rdx
  unsigned int v6; // ecx

  v3 = *(unsigned int **)(a1 + 24);
  if ( *(_DWORD *)(a2 + 16) != 12 || *(_DWORD *)(a2 + 8) < 8u )
    return 3221225485i64;
  v4 = v3[1];
  v5 = (v4 + ((unsigned __int64)v3[2] << 32)) >> 32;
  v6 = *v3;
  __writemsr(v6, __PAIR64__(v5, v4));
  **(_QWORD **)(a1 + 24) = __readmsr(v6);
  *(_QWORD *)(a1 + 56) = 8i64;
  return 0i64;
}
~~~



### IOCTL  0xA040A460

This IOCTL code triggers the read operation on MSR. 

~~~c
__int64 __fastcall sub_11040(__int64 a1, __int64 a2)
{
  _DWORD *v2; // r10
  unsigned __int64 v3; // r8

  v2 = *(_DWORD **)(a1 + 24);
  if ( *(_DWORD *)(a2 + 16) != 4 || *(_DWORD *)(a2 + 8) < 4u )
    return 3221225485i64;
  v3 = __readmsr(0x2Du) >> 32;
  __writemsr(0x2Du, (unsigned int)*v2 + (v3 << 32));
  *v2 = v3;
  *(_QWORD *)(a1 + 56) = 4i64;
  return 0i64;
}
~~~







### IOCTL 0xA040A440(out byte), 0xA040A444(out word), 0xA040A448(out dword)

This code triggers port out operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_11410(__int64 a1, __int64 a2, char a3)
{
  int v4; // r12d
  unsigned int v5; // edx
  unsigned __int8 *v6; // rdi
  unsigned __int8 *QuadPart; // rbx
  ULONG v8; // eax
  unsigned int v10; // eax
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v4 = *(_DWORD *)(a2 + 24);
  v5 = *(_DWORD *)(a2 + 16);
  if ( a3 )
  {
    v6 = *(unsigned __int8 **)(a1 + 24);
    QuadPart = (unsigned __int8 *)BusAddress.QuadPart;
  }
  else
  {
    QuadPart = *(unsigned __int8 **)(a1 + 24);
    v6 = (unsigned __int8 *)BusAddress.QuadPart;
  }
  switch ( v4 )
  {
    case 0xA040A440:
      v8 = 1;
      break;
    case 0xA040A444:
      v8 = 2;
      break;
    case 0xA040A448:
      v8 = 4;
      break;
    default:
      v8 = AddressSpace;
      break;
  }
  if ( v5 < (unsigned __int64)v8 + 4 )
    return 3221225485i64;
  if ( a3 )
  {
    v10 = *(_DWORD *)v6;
    v6 += 4;
  }
  else
  {
    v10 = *(_DWORD *)QuadPart;
    QuadPart += 4;
  }
  BusAddress.QuadPart = v10;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, (PHYSICAL_ADDRESS)v10, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    switch ( v4 )
    {
      case 0xA040A440:
        if ( a3 )
          __outbyte(BusAddress.LowPart, *v6);
        else
          __outbyte((unsigned __int16)&BusAddress, *QuadPart);
        break;
      case 0xA040A444:
        if ( a3 )
          __outword(BusAddress.LowPart, *(_WORD *)v6);
        else
          __outword((unsigned __int16)&BusAddress, *(_WORD *)QuadPart);
        break;
      case 0xA040A448:
        if ( a3 )
          __outdword(BusAddress.LowPart, *(_DWORD *)v6);
        else
          __outdword((unsigned __int16)&BusAddress, *(_DWORD *)QuadPart);
        break;
    }
    return 0i64;
  }
  switch ( v4 )
  {
    case 0xA040A440:
      if ( a3 )
        *(_BYTE *)BusAddress.LowPart = *v6;
      else
        LOBYTE(BusAddress.LowPart) = *QuadPart;
      goto LABEL_41;
    case 0xA040A444:
      if ( a3 )
        *(_WORD *)BusAddress.LowPart = *(_WORD *)v6;
      else
        LOWORD(BusAddress.LowPart) = *(_WORD *)QuadPart;
      goto LABEL_41;
    case 0xA040A448:
      if ( a3 )
        *(_DWORD *)BusAddress.LowPart = *(_DWORD *)v6;
      else
        BusAddress.LowPart = *(_DWORD *)QuadPart;
LABEL_41:
      _mm_sfence();
      break;
  }
  return 0i64;
}
```



### IOCTL 0xA0406400(in byte), 0xA0406404(in word) , 0xA0406408(in dword)

This code triggers port in operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_11260(__int64 a1, _DWORD *a2)
{
  int v3; // ebx
  _BYTE *v4; // rdi
  ULONG v5; // esi
  unsigned __int32 v6; // eax
  unsigned __int16 v8; // ax
  unsigned __int8 v9; // al
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v3 = a2[6];
  v4 = *(_BYTE **)(a1 + 24);
  switch ( v3 )
  {
    case 0xA0406400:
      v5 = 1;
      break;
    case 0xA0406404:
      v5 = 2;
      break;
    case 0xA0406408:
      v5 = 4;
      break;
    default:
      v5 = AddressSpace;
      break;
  }
  if ( a2[4] != 4 || a2[2] < v5 )
    return 3221225485i64;
  BusAddress.QuadPart = *(unsigned int *)v4;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, BusAddress, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    switch ( v3 )
    {
      case 0xA0406400:
        v9 = __inbyte(BusAddress.LowPart);
        *v4 = v9;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406404:
        v8 = __inword(BusAddress.LowPart);
        *(_WORD *)v4 = v8;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406408:
        v6 = __indword(BusAddress.LowPart);
        *(_DWORD *)v4 = v6;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
    }
  }
  else
  {
    switch ( v3 )
    {
      case 0xA0406400:
        *v4 = *(_BYTE *)BusAddress.LowPart;
        break;
      case 0xA0406404:
        *(_WORD *)v4 = *(_WORD *)BusAddress.LowPart;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406408:
        *(_DWORD *)v4 = *(_DWORD *)BusAddress.LowPart;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
    }
  }
  *(_QWORD *)(a1 + 56) = v5;
  return 0i64;
}
```



### IOCTL  0xA040244C

This code triggers memory map operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_115C0(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v5; // rdi
  _DWORD *v6; // r13
  NTSTATUS v7; // ebx
  void *v8; // rcx
  _DWORD *v10; // r14
  LARGE_INTEGER v11; // rax
  DWORD v12; // ecx
  DWORD LowPart; // eax
  LARGE_INTEGER TranslatedAddress; // [rsp+50h] [rbp-D8h] BYREF
  ULONG AddressSpace; // [rsp+58h] [rbp-D0h] BYREF
  union _LARGE_INTEGER SectionOffset; // [rsp+60h] [rbp-C8h] BYREF
  void *SectionHandle; // [rsp+68h] [rbp-C0h] BYREF
  HANDLE Handle; // [rsp+70h] [rbp-B8h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+78h] [rbp-B0h] BYREF
  PVOID BaseAddress; // [rsp+80h] [rbp-A8h] BYREF
  ULONG_PTR ViewSize; // [rsp+88h] [rbp-A0h] BYREF
  PVOID v22; // [rsp+90h] [rbp-98h] BYREF
  ULONG v23; // [rsp+98h] [rbp-90h] BYREF
  PVOID v24; // [rsp+A0h] [rbp-88h] BYREF
  PVOID Object; // [rsp+A8h] [rbp-80h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+B0h] [rbp-78h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+E0h] [rbp-48h] BYREF

  Handle = 0i64;
  v22 = 0i64;
  SectionHandle = 0i64;
  Object = 0i64;
  v5 = *(_QWORD *)(a2 + 24);
  if ( a4 )
  {
    v6 = *(_DWORD **)(a2 + 24);
    if ( *(_DWORD *)(a3 + 16) < 0x18u || *(_DWORD *)(a3 + 8) < 4u )
    {
      v7 = -1073741670;
      goto LABEL_5;
    }
    v10 = v22;
  }
  else
  {
    v10 = *(_DWORD **)(a2 + 24);
    if ( *(_DWORD *)(a3 + 16) < 0x18u || *(_DWORD *)(a3 + 8) < 8u )
      return (unsigned int)-1073741670;
    v6 = v22;
  }
  AddressSpace = *(_DWORD *)(v5 + 16);
  v23 = AddressSpace;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  if ( a4 )
  {
    v7 = ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes);
    if ( v7 < 0 )
      goto LABEL_5;
    v7 = ObReferenceObjectByHandle(SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
    if ( v7 < 0 )
      goto LABEL_5;
  }
  else
  {
    v7 = ZwOpenSection(&Handle, 0xF001Fu, &ObjectAttributes);
    if ( v7 < 0 )
      goto LABEL_6;
    v7 = ObReferenceObjectByHandle(Handle, 0xF001Fu, 0i64, 0, &v22, 0i64);
    if ( v7 < 0 )
      goto LABEL_6;
  }
  BusAddress.QuadPart = *(_QWORD *)(v5 + 8) + *(_DWORD *)(v5 + 20) + (unsigned int)(unsigned __int16)*(_DWORD *)(v5 + 8);
  if ( HalTranslateBusAddress(
         *(INTERFACE_TYPE *)v5,
         *(_DWORD *)(v5 + 4),
         *(PHYSICAL_ADDRESS *)(v5 + 8),
         &AddressSpace,
         &TranslatedAddress)
    && HalTranslateBusAddress(*(INTERFACE_TYPE *)v5, *(_DWORD *)(v5 + 4), BusAddress, &v23, &BusAddress) )
  {
    v11 = TranslatedAddress;
  }
  else
  {
    v11 = *(LARGE_INTEGER *)(v5 + 8);
    TranslatedAddress = v11;
  }
  v12 = BusAddress.LowPart - v11.LowPart;
  ViewSize = BusAddress.QuadPart - v11.QuadPart;
  if ( BusAddress.LowPart == v11.LowPart )
  {
    v7 = -1073741823;
    goto LABEL_5;
  }
  if ( AddressSpace )
  {
    LowPart = TranslatedAddress.LowPart;
    if ( a4 )
    {
      *v6 = TranslatedAddress.LowPart;
      v7 = 0;
      goto LABEL_5;
    }
    goto LABEL_34;
  }
  SectionOffset = v11;
  if ( a4 )
  {
    BaseAddress = 0i64;
    v7 = ZwMapViewOfSection(
           SectionHandle,
           (HANDLE)0xFFFFFFFFFFFFFFFFi64,
           &BaseAddress,
           0i64,
           v12,
           &SectionOffset,
           &ViewSize,
           ViewShare,
           0,
           4u);
    if ( v7 >= 0 )
    {
      LODWORD(BaseAddress) = TranslatedAddress.LowPart - SectionOffset.LowPart + (_DWORD)BaseAddress;
      *v6 = (_DWORD)BaseAddress;
      v7 = 0;
    }
LABEL_5:
    v8 = SectionHandle;
    if ( a4 )
      goto LABEL_7;
    goto LABEL_6;
  }
  v24 = 0i64;
  v7 = ZwMapViewOfSection(
         Handle,
         (HANDLE)0xFFFFFFFFFFFFFFFFi64,
         &v24,
         0i64,
         v12,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v7 >= 0 )
  {
    LowPart = TranslatedAddress.LowPart + (_DWORD)v24 - SectionOffset.LowPart;
LABEL_34:
    *v10 = LowPart;
    v7 = 0;
    goto LABEL_5;
  }
LABEL_6:
  v8 = Handle;
LABEL_7:
  if ( v8 )
    ZwClose(v8);
  return (unsigned int)v7;
}
```



