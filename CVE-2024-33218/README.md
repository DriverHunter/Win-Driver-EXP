# Vulnerable Driver AsUpIO64.sys in ASUS USB 3.0 Boost Storage Driver 5.30.20.0   

---

Many vulnerability exits in driver AsUpIO64.sys, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port and even read/write arbitary MSR via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

5.30.20.0 

## Vulnerability causes

AsUpIO64.sys  provides the functionality of mapping physical memory and read/write I/O ports and arbitrary read/write MSR, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall ioctler(__int64 a1, IRP *a2)
{
  BOOLEAN is32bitprocess; // si
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  NTSTATUS v6; // ebx
  UCHAR MajorFunction; // al
  unsigned int LowPart; // eax
  void *Type; // rdx
  __int64 v10; // rax
  struct _IRP *MasterIrp; // rbx
  PVOID ContiguousMemory; // rax
  __int64 v14; // [rsp+20h] [rbp-38h]

  is32bitprocess = IoIs32bitProcess(a2);
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  v6 = -1073741822;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( !CurrentStackLocation->MajorFunction || MajorFunction == 2 )
  {
LABEL_41:
    v6 = 0;
    goto LABEL_42;
  }
  if ( MajorFunction != 14 )
    goto LABEL_42;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  if ( LowPart > 0xA040A45C )
  {
    switch ( LowPart )
    {
      case 0xA040A460:
        v6 = ((__int64 (__fastcall *)(IRP *))sub_110B0)(a2);
        if ( v6 >= 0 )
          a2->IoStatus.Information = 8i64;
        break;
      case 0xA040A464:
        v6 = ((__int64 (__fastcall *)(IRP *))sub_111C0)(a2);
        if ( v6 >= 0 )
          a2->IoStatus.Information = 4i64;
        break;
      case 0xA040A480:
        goto LABEL_35;
      case 0xA040A488:
        MasterIrp = a2->AssociatedIrp.MasterIrp;
        ContiguousMemory = MmAllocateContiguousMemory(
                             *(unsigned int *)&MasterIrp->Type,
                             (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
        HIDWORD(v14) = (_DWORD)ContiguousMemory;
        LODWORD(v14) = MmGetPhysicalAddress(ContiguousMemory).LowPart;
        *(_QWORD *)&MasterIrp->Type = v14;
        a2->IoStatus.Information = 8i64;
        goto LABEL_41;
      case 0xA040A48C:
        goto LABEL_41;
      case 0xA040A540:
      case 0xA040A544:
      case 0xA040A548:
        v6 = sub_11A20((__int64)a2, (__int64)CurrentStackLocation, is32bitprocess);
        break;
      default:
        goto LABEL_42;
    }
    goto LABEL_42;
  }
  if ( LowPart == 0xA040A45C )
  {
    v6 = ((__int64 (__fastcall *)(IRP *))wrmsr_func)(a2);// read write arbitary msr primitive
    if ( v6 >= 0 )
      a2->IoStatus.Information = 8i64;
    goto LABEL_42;
  }
  if ( LowPart > 0xA0406408 )
  {
    if ( LowPart == -1606392744 )
    {
      v6 = readmsr_func((__int64)a2);
      if ( v6 >= 0 )
        a2->IoStatus.Information = 8i64;
    }
    else if ( LowPart == 0xA040A440 || LowPart == 0xA040A444 || LowPart == 0xA040A448 )
    {
      v6 = sub_11470((__int64)a2, (__int64)CurrentStackLocation, is32bitprocess);// out primitive
    }
    goto LABEL_42;
  }
  switch ( LowPart )
  {
    case 0xA0406408:
LABEL_12:
      v6 = ((__int64 (__fastcall *)(IRP *, struct _IO_STACK_LOCATION *, _QWORD))in_func)(// in primitive
             a2,
             CurrentStackLocation,
             is32bitprocess);
      break;
    case 0xA040244C:
LABEL_35:
      v6 = sub_11620(a1, (__int64)a2, (__int64)a2->Tail.Overlay.CurrentStackLocation, is32bitprocess);// zwmapviewofsection   primitive
      if ( v6 < 0 )
      {
        a2->IoStatus.Status = -1073741811;
      }
      else
      {
        v10 = 8i64;
        if ( is32bitprocess )
          v10 = 4i64;
        a2->IoStatus.Information = v10;
      }
      break;
    case 0xA0402450:
      if ( is32bitprocess )
      {
        if ( CurrentStackLocation->Parameters.Create.Options >= 4 )
        {
          Type = (void *)a2->AssociatedIrp.MasterIrp->Type;
LABEL_16:
          v6 = ZwUnmapViewOfSection((HANDLE)0xFFFFFFFFFFFFFFFFi64, Type);
          break;
        }
      }
      else if ( CurrentStackLocation->Parameters.Create.Options >= 8 )
      {
        Type = *(void **)a2->AssociatedIrp.MasterIrp;
        goto LABEL_16;
      }
      v6 = -1073741670;
      break;
    case 0xA0406400:
    case 0xA0406404:
      goto LABEL_12;
  }
LABEL_42:
  a2->IoStatus.Status = v6;
  IofCompleteRequest(a2, 0);
  return (unsigned int)v6;
}
~~~

### IOCTL  0xA040A45C

This IOCTL code triggers the read/write operation on MSR. 

~~~c
__int64 __fastcall sub_11120(__int64 a1, __int64 a2)
{
  unsigned int *v3; // rax
  unsigned int v4; // r8d
  unsigned __int64 v5; // rax
  _DWORD *v6; // rcx

  v3 = *(unsigned int **)(a1 + 0x18);
  if ( *(_DWORD *)(a2 + 0x10) != 12 || *(_DWORD *)(a2 + 8) < 8u )
    return 0xC000000Di64;
  v4 = *v3;
  __writemsr(*v3, v3[1]);
  v5 = __readmsr(v4);
  v6 = *(_DWORD **)(a1 + 0x18);
  *v6 = HIDWORD(v5);
  v6[1] = v5;
  *(_QWORD *)(a1 + 56) = 8i64;
  return 0i64;
}
~~~

### IOCTL 0xA040A440 (out byte), 0xA040A444 (out word), 0xA040A448 (out dword)

This code triggers port out operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_11470(__int64 a1, __int64 a2, char a3)
{
  int v4; // r12d
  unsigned int v5; // edx
  unsigned __int8 *v6; // rdi
  unsigned __int8 *QuadPart; // rbx
  ULONG v8; // eax
  unsigned int v10; // eax
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v4 = *(_DWORD *)(a2 + 24);
  v5 = *(_DWORD *)(a2 + 16);
  if ( a3 )
  {
    v6 = *(unsigned __int8 **)(a1 + 24);
    QuadPart = (unsigned __int8 *)BusAddress.QuadPart;
  }
  else
  {
    QuadPart = *(unsigned __int8 **)(a1 + 24);
    v6 = (unsigned __int8 *)BusAddress.QuadPart;
  }
  switch ( v4 )
  {
    case 0xA040A440:
      v8 = 1;
      break;
    case 0xA040A444:
      v8 = 2;
      break;
    case 0xA040A448:
      v8 = 4;
      break;
    default:
      v8 = AddressSpace;
      break;
  }
  if ( v5 < (unsigned __int64)v8 + 4 )
    return 0xC000000Di64;
  if ( a3 )
  {
    v10 = *(_DWORD *)v6;
    v6 += 4;
  }
  else
  {
    v10 = *(_DWORD *)QuadPart;
    QuadPart += 4;
  }
  BusAddress.QuadPart = v10;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, (PHYSICAL_ADDRESS)v10, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    switch ( v4 )
    {
      case 0xA040A440:
        if ( a3 )
          __outbyte(BusAddress.LowPart, *v6);
        else
          __outbyte((unsigned __int16)&BusAddress, *QuadPart);
        break;
      case 0xA040A444:
        if ( a3 )
          __outword(BusAddress.LowPart, *(_WORD *)v6);
        else
          __outword((unsigned __int16)&BusAddress, *(_WORD *)QuadPart);
        break;
      case 0xA040A448:
        if ( a3 )
          __outdword(BusAddress.LowPart, *(_DWORD *)v6);
        else
          __outdword((unsigned __int16)&BusAddress, *(_DWORD *)QuadPart);
        break;
    }
    return 0i64;
  }
  switch ( v4 )
  {
    case -1606376384:
      if ( a3 )
        *(_BYTE *)BusAddress.LowPart = *v6;
      else
        LOBYTE(BusAddress.LowPart) = *QuadPart;
      goto LABEL_41;
    case -1606376380:
      if ( a3 )
        *(_WORD *)BusAddress.LowPart = *(_WORD *)v6;
      else
        LOWORD(BusAddress.LowPart) = *(_WORD *)QuadPart;
      goto LABEL_41;
    case -1606376376:
      if ( a3 )
        *(_DWORD *)BusAddress.LowPart = *(_DWORD *)v6;
      else
        BusAddress.LowPart = *(_DWORD *)QuadPart;
LABEL_41:
      _mm_sfence();
      break;
  }
  return 0i64;
}
```



### IOCTL 0xA0406400(in byte), 0xA0406404(in word) , 0xA0406408(in dword)

This code triggers port in operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_112C0(__int64 a1, _DWORD *a2)
{
  int v3; // ebx
  _BYTE *v4; // rdi
  ULONG v5; // esi
  unsigned __int32 v6; // eax
  unsigned __int16 v8; // ax
  unsigned __int8 v9; // al
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v3 = a2[6];
  v4 = *(_BYTE **)(a1 + 24);
  switch ( v3 )
  {
    case 0xA0406400:
      v5 = 1;
      break;
    case 0xA0406404:
      v5 = 2;
      break;
    case 0xA0406408:
      v5 = 4;
      break;
    default:
      v5 = AddressSpace;
      break;
  }
  if ( a2[4] != 4 || a2[2] < v5 )
    return 3221225485i64;
  BusAddress.QuadPart = *(unsigned int *)v4;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, BusAddress, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    switch ( v3 )
    {
      case 0xA0406400:
        v9 = __inbyte(BusAddress.LowPart);
        *v4 = v9;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406404:
        v8 = __inword(BusAddress.LowPart);
        *(_WORD *)v4 = v8;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406408:
        v6 = __indword(BusAddress.LowPart);
        *(_DWORD *)v4 = v6;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
    }
  }
  else
  {
    switch ( v3 )
    {
      case -1606392832:
        *v4 = *(_BYTE *)BusAddress.LowPart;
        break;
      case -1606392828:
        *(_WORD *)v4 = *(_WORD *)BusAddress.LowPart;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case -1606392824:
        *(_DWORD *)v4 = *(_DWORD *)BusAddress.LowPart;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
    }
  }
  *(_QWORD *)(a1 + 56) = v5;
  return 0i64;
}
```

