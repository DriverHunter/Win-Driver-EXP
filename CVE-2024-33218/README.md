# Vulnerable Driver AsUpIO64.sys in ASUS USB 3.0 Boost Storage Driver 5.30.20.0   

---

Many vulnerability exits in driver AsUpIO64.sys, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port and even read/write arbitary MSR via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

5.30.20.0 

## Vulnerability causes

AsUpIO64.sys  provides the functionality of mapping physical memory and read/write I/O ports and arbitrary read/write MSR, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall ioctler(__int64 a1, IRP *a2)
{
  BOOLEAN is32bitprocess; // si
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  NTSTATUS v6; // ebx
  UCHAR MajorFunction; // al
  unsigned int LowPart; // eax
  void *Type; // rdx
  __int64 v10; // rax
  struct _IRP *MasterIrp; // rbx
  PVOID ContiguousMemory; // rax
  __int64 v14; // [rsp+20h] [rbp-38h]

  is32bitprocess = IoIs32bitProcess(a2);
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  v6 = -1073741822;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( !CurrentStackLocation->MajorFunction || MajorFunction == 2 )
  {
LABEL_41:
    v6 = 0;
    goto LABEL_42;
  }
  if ( MajorFunction != 14 )
    goto LABEL_42;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  if ( LowPart > 0xA040A45C )
  {
    switch ( LowPart )
    {
      case 0xA040A460:
        v6 = ((__int64 (__fastcall *)(IRP *))sub_110B0)(a2);
        if ( v6 >= 0 )
          a2->IoStatus.Information = 8i64;
        break;
      case 0xA040A464:
        v6 = ((__int64 (__fastcall *)(IRP *))sub_111C0)(a2);
        if ( v6 >= 0 )
          a2->IoStatus.Information = 4i64;
        break;
      case 0xA040A480:
        goto LABEL_35;
      case 0xA040A488:
        MasterIrp = a2->AssociatedIrp.MasterIrp;
        ContiguousMemory = MmAllocateContiguousMemory(
                             *(unsigned int *)&MasterIrp->Type,
                             (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
        HIDWORD(v14) = (_DWORD)ContiguousMemory;
        LODWORD(v14) = MmGetPhysicalAddress(ContiguousMemory).LowPart;
        *(_QWORD *)&MasterIrp->Type = v14;
        a2->IoStatus.Information = 8i64;
        goto LABEL_41;
      case 0xA040A48C:
        goto LABEL_41;
      case 0xA040A540:
      case 0xA040A544:
      case 0xA040A548:
        v6 = sub_11A20((__int64)a2, (__int64)CurrentStackLocation, is32bitprocess);
        break;
      default:
        goto LABEL_42;
    }
    goto LABEL_42;
  }
  if ( LowPart == 0xA040A45C )
  {
    v6 = ((__int64 (__fastcall *)(IRP *))wrmsr_func)(a2);// read write arbitary msr primitive
    if ( v6 >= 0 )
      a2->IoStatus.Information = 8i64;
    goto LABEL_42;
  }
  if ( LowPart > 0xA0406408 )
  {
    if ( LowPart == 0xA0406458 )
    {
      v6 = readmsr_func((__int64)a2);//rdmsr primitive
      if ( v6 >= 0 )
        a2->IoStatus.Information = 8i64;
    }
    else if ( LowPart == 0xA040A440 || LowPart == 0xA040A444 || LowPart == 0xA040A448 )
    {
      v6 = sub_11470((__int64)a2, (__int64)CurrentStackLocation, is32bitprocess);// out primitive
    }
    goto LABEL_42;
  }
  switch ( LowPart )
  {
    case 0xA0406408:
LABEL_12:
      v6 = ((__int64 (__fastcall *)(IRP *, struct _IO_STACK_LOCATION *, _QWORD))in_func)(// in primitive
             a2,
             CurrentStackLocation,
             is32bitprocess);
      break;
    case 0xA040244C:
LABEL_35:
      v6 = sub_11620(a1, (__int64)a2, (__int64)a2->Tail.Overlay.CurrentStackLocation, is32bitprocess);// zwmapviewofsection   primitive
      if ( v6 < 0 )
      {
        a2->IoStatus.Status = -1073741811;
      }
      else
      {
        v10 = 8i64;
        if ( is32bitprocess )
          v10 = 4i64;
        a2->IoStatus.Information = v10;
      }
      break;
    case 0xA0402450:
      if ( is32bitprocess )
      {
        if ( CurrentStackLocation->Parameters.Create.Options >= 4 )
        {
          Type = (void *)a2->AssociatedIrp.MasterIrp->Type;
LABEL_16:
          v6 = ZwUnmapViewOfSection((HANDLE)0xFFFFFFFFFFFFFFFFi64, Type);
          break;
        }
      }
      else if ( CurrentStackLocation->Parameters.Create.Options >= 8 )
      {
        Type = *(void **)a2->AssociatedIrp.MasterIrp;
        goto LABEL_16;
      }
      v6 = -1073741670;
      break;
    case 0xA0406400:
    case 0xA0406404:
      goto LABEL_12;
  }
LABEL_42:
  a2->IoStatus.Status = v6;
  IofCompleteRequest(a2, 0);
  return (unsigned int)v6;
}
~~~

### IOCTL  0xA040A45C

This IOCTL code triggers the read/write operation on MSR. 

~~~c
__int64 __fastcall sub_11120(__int64 a1, __int64 a2)
{
  unsigned int *v3; // rax
  unsigned int v4; // r8d
  unsigned __int64 v5; // rax
  _DWORD *v6; // rcx

  v3 = *(unsigned int **)(a1 + 0x18);
  if ( *(_DWORD *)(a2 + 0x10) != 12 || *(_DWORD *)(a2 + 8) < 8u )
    return 0xC000000Di64;
  v4 = *v3;
  __writemsr(*v3, v3[1]);
  v5 = __readmsr(v4);
  v6 = *(_DWORD **)(a1 + 0x18);
  *v6 = HIDWORD(v5);
  v6[1] = v5;
  *(_QWORD *)(a1 + 56) = 8i64;
  return 0i64;
}
~~~



### IOCTL  0xA0406458

This IOCTL code triggers the read operation on MSR. 

~~~c
__int64 __fastcall sub_11070(__int64 a1)
{
  **(_QWORD **)(a1 + 24) = __readmsr(**(_DWORD **)(a1 + 24));
  *(_QWORD *)(a1 + 56) = 8i64;
  return 0i64;
}
~~~





### IOCTL 0xA040A440 (out byte), 0xA040A444 (out word), 0xA040A448 (out dword)

This code triggers port out operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_11470(__int64 a1, __int64 a2, char a3)
{
  int v4; // r12d
  unsigned int v5; // edx
  unsigned __int8 *v6; // rdi
  unsigned __int8 *QuadPart; // rbx
  ULONG v8; // eax
  unsigned int v10; // eax
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v4 = *(_DWORD *)(a2 + 24);
  v5 = *(_DWORD *)(a2 + 16);
  if ( a3 )
  {
    v6 = *(unsigned __int8 **)(a1 + 24);
    QuadPart = (unsigned __int8 *)BusAddress.QuadPart;
  }
  else
  {
    QuadPart = *(unsigned __int8 **)(a1 + 24);
    v6 = (unsigned __int8 *)BusAddress.QuadPart;
  }
  switch ( v4 )
  {
    case 0xA040A440:
      v8 = 1;
      break;
    case 0xA040A444:
      v8 = 2;
      break;
    case 0xA040A448:
      v8 = 4;
      break;
    default:
      v8 = AddressSpace;
      break;
  }
  if ( v5 < (unsigned __int64)v8 + 4 )
    return 0xC000000Di64;
  if ( a3 )
  {
    v10 = *(_DWORD *)v6;
    v6 += 4;
  }
  else
  {
    v10 = *(_DWORD *)QuadPart;
    QuadPart += 4;
  }
  BusAddress.QuadPart = v10;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, (PHYSICAL_ADDRESS)v10, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    switch ( v4 )
    {
      case 0xA040A440:
        if ( a3 )
          __outbyte(BusAddress.LowPart, *v6);
        else
          __outbyte((unsigned __int16)&BusAddress, *QuadPart);
        break;
      case 0xA040A444:
        if ( a3 )
          __outword(BusAddress.LowPart, *(_WORD *)v6);
        else
          __outword((unsigned __int16)&BusAddress, *(_WORD *)QuadPart);
        break;
      case 0xA040A448:
        if ( a3 )
          __outdword(BusAddress.LowPart, *(_DWORD *)v6);
        else
          __outdword((unsigned __int16)&BusAddress, *(_DWORD *)QuadPart);
        break;
    }
    return 0i64;
  }
  switch ( v4 )
  {
    case -1606376384:
      if ( a3 )
        *(_BYTE *)BusAddress.LowPart = *v6;
      else
        LOBYTE(BusAddress.LowPart) = *QuadPart;
      goto LABEL_41;
    case -1606376380:
      if ( a3 )
        *(_WORD *)BusAddress.LowPart = *(_WORD *)v6;
      else
        LOWORD(BusAddress.LowPart) = *(_WORD *)QuadPart;
      goto LABEL_41;
    case -1606376376:
      if ( a3 )
        *(_DWORD *)BusAddress.LowPart = *(_DWORD *)v6;
      else
        BusAddress.LowPart = *(_DWORD *)QuadPart;
LABEL_41:
      _mm_sfence();
      break;
  }
  return 0i64;
}
```



### IOCTL 0xA0406400(in byte), 0xA0406404(in word) , 0xA0406408(in dword)

This code triggers port in operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_112C0(__int64 a1, _DWORD *a2)
{
  int v3; // ebx
  _BYTE *v4; // rdi
  ULONG v5; // esi
  unsigned __int32 v6; // eax
  unsigned __int16 v8; // ax
  unsigned __int8 v9; // al
  ULONG AddressSpace; // [rsp+30h] [rbp-48h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+38h] [rbp-40h] BYREF

  v3 = a2[6];
  v4 = *(_BYTE **)(a1 + 24);
  switch ( v3 )
  {
    case 0xA0406400:
      v5 = 1;
      break;
    case 0xA0406404:
      v5 = 2;
      break;
    case 0xA0406408:
      v5 = 4;
      break;
    default:
      v5 = AddressSpace;
      break;
  }
  if ( a2[4] != 4 || a2[2] < v5 )
    return 3221225485i64;
  BusAddress.QuadPart = *(unsigned int *)v4;
  AddressSpace = 1;
  HalTranslateBusAddress(Isa, 0, BusAddress, &AddressSpace, &BusAddress);
  if ( AddressSpace == 1 )
  {
    switch ( v3 )
    {
      case 0xA0406400:
        v9 = __inbyte(BusAddress.LowPart);
        *v4 = v9;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406404:
        v8 = __inword(BusAddress.LowPart);
        *(_WORD *)v4 = v8;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case 0xA0406408:
        v6 = __indword(BusAddress.LowPart);
        *(_DWORD *)v4 = v6;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
    }
  }
  else
  {
    switch ( v3 )
    {
      case -1606392832:
        *v4 = *(_BYTE *)BusAddress.LowPart;
        break;
      case -1606392828:
        *(_WORD *)v4 = *(_WORD *)BusAddress.LowPart;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
      case -1606392824:
        *(_DWORD *)v4 = *(_DWORD *)BusAddress.LowPart;
        *(_QWORD *)(a1 + 56) = v5;
        return 0i64;
    }
  }
  *(_QWORD *)(a1 + 56) = v5;
  return 0i64;
}
```

### IOCTL 0xA040244C

This code triggers memory map operation. The operation is eventually completed in function below.

```c
__int64 __fastcall sub_11620(__int64 a1, __int64 a2, __int64 a3, char is32bitprocess)
{
  __int64 v5; // rdi
  _DWORD *v6; // r13
  NTSTATUS v7; // ebx
  HANDLE v8; // rcx
  _DWORD *v9; // r14
  DWORD v10; // ecx
  DWORD LowPart; // eax
  void *SectionHandle; // [rsp+50h] [rbp-D8h] BYREF
  ULONG AddressSpace; // [rsp+58h] [rbp-D0h] BYREF
  LARGE_INTEGER TranslatedAddress; // [rsp+60h] [rbp-C8h] BYREF
  union _LARGE_INTEGER SectionOffset; // [rsp+68h] [rbp-C0h] BYREF
  HANDLE Handle; // [rsp+70h] [rbp-B8h] BYREF
  ULONG_PTR ViewSize; // [rsp+78h] [rbp-B0h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+80h] [rbp-A8h] BYREF
  PVOID Object; // [rsp+88h] [rbp-A0h] BYREF
  PVOID v21; // [rsp+90h] [rbp-98h] BYREF
  ULONG v22; // [rsp+98h] [rbp-90h] BYREF
  PVOID BaseAddress; // [rsp+A0h] [rbp-88h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+A8h] [rbp-80h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+D8h] [rbp-50h] BYREF

  Handle = 0i64;
  v21 = 0i64;
  LODWORD(SectionHandle) = 0;
  LODWORD(Object) = 0;
  v5 = *(_QWORD *)(a2 + 24);
  if ( is32bitprocess )
  {
    v6 = *(_DWORD **)(a2 + 24);
    if ( *(_DWORD *)(a3 + 16) < 0x18u || *(_DWORD *)(a3 + 8) < 4u )
    {
      v7 = -1073741670;
      goto LABEL_5;
    }
    v9 = v21;
  }
  else
  {
    v9 = *(_DWORD **)(a2 + 24);
    if ( *(_DWORD *)(a3 + 16) < 0x18u || *(_DWORD *)(a3 + 8) < 8u )
      return (unsigned int)-1073741670;
    v6 = v21;
  }
  AddressSpace = *(_DWORD *)(v5 + 16);
  v22 = AddressSpace;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  if ( is32bitprocess )
  {
    v7 = ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes);
    if ( v7 < 0 )
      goto LABEL_5;
    v7 = ObReferenceObjectByHandle((HANDLE)(int)SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
    if ( v7 < 0 )
      goto LABEL_5;
  }
  else
  {
    v7 = ZwOpenSection(&Handle, 0xF001Fu, &ObjectAttributes);
    if ( v7 < 0 )
      goto LABEL_32;
    v7 = ObReferenceObjectByHandle(Handle, 0xF001Fu, 0i64, 0, &v21, 0i64);
    if ( v7 < 0 )
      goto LABEL_32;
  }
  BusAddress.QuadPart = *(_QWORD *)(v5 + 8) + *(_DWORD *)(v5 + 20) + (unsigned int)(unsigned __int16)*(_DWORD *)(v5 + 8);
  if ( !HalTranslateBusAddress(
          *(INTERFACE_TYPE *)v5,
          *(_DWORD *)(v5 + 4),
          *(PHYSICAL_ADDRESS *)(v5 + 8),
          &AddressSpace,
          &TranslatedAddress)
    || !HalTranslateBusAddress(*(INTERFACE_TYPE *)v5, *(_DWORD *)(v5 + 4), BusAddress, &v22, &BusAddress)
    || (v10 = BusAddress.LowPart - TranslatedAddress.LowPart,
        ViewSize = BusAddress.QuadPart - TranslatedAddress.QuadPart,
        BusAddress.LowPart == TranslatedAddress.LowPart) )
  {
    v7 = -1073741823;
    goto LABEL_5;
  }
  if ( AddressSpace )
  {
    LowPart = TranslatedAddress.LowPart;
    if ( is32bitprocess )
    {
      *v6 = TranslatedAddress.LowPart;
      v7 = 0;
      goto LABEL_5;
    }
    goto LABEL_30;
  }
  SectionOffset = TranslatedAddress;
  if ( !is32bitprocess )
  {
    BaseAddress = 0i64;
    v7 = ZwMapViewOfSection(
           Handle,
           (HANDLE)0xFFFFFFFFFFFFFFFFi64,
           &BaseAddress,
           0i64,
           v10,
           &SectionOffset,
           &ViewSize,
           ViewShare,
           0,
           4u);
    if ( v7 >= 0 )
    {
      LowPart = TranslatedAddress.LowPart + (_DWORD)BaseAddress - SectionOffset.LowPart;
LABEL_30:
      *v9 = LowPart;
      v7 = 0;
      goto LABEL_5;
    }
LABEL_32:
    v8 = Handle;
    if ( Handle )
      goto LABEL_33;
    return (unsigned int)v7;
  }
  HIDWORD(SectionHandle) = 0;
  v7 = ZwMapViewOfSection(
         (HANDLE)(int)SectionHandle,
         (HANDLE)0xFFFFFFFFFFFFFFFFi64,
         (void **)((char *)&SectionHandle + 4),
         0i64,
         v10,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v7 >= 0 )
  {
    HIDWORD(SectionHandle) += TranslatedAddress.LowPart - SectionOffset.LowPart;
    *v6 = HIDWORD(SectionHandle);
    v7 = 0;
  }
LABEL_5:
  if ( !is32bitprocess )
    goto LABEL_32;
  if ( (_DWORD)SectionHandle )
  {
    v8 = (HANDLE)(int)SectionHandle;
LABEL_33:
    ZwClose(v8);
  }
  return (unsigned int)v7;
}
```

