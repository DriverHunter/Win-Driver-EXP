# Vulnerable Driver IOMap64.sys in ASUS GPU TweakII v1.4.5.2

---

IOMap64.sys in ASUS GPU TweakII v1.4.5.2 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

1.4.5.2

## Vulnerability causes

IOMap64.sys provides the functionality of mapping physical memory, read/write I/O ports , but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_11294(__int64 a1, IRP *a2)
{
  __int64 v3; // rbp
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rcx
  ULONG_PTR *p_Information; // rsi
  struct _IRP *MasterIrp; // rdi
  __int64 Length; // r8
  __int64 Options; // rdx
  unsigned int LowPart; // eax
  char v10; // al
  unsigned __int32 v11; // eax
  unsigned int Status; // edi
  int v14; // eax
  PVOID v15; // rcx
  int v16; // eax
  unsigned int v17; // ecx
  ULONG v18; // eax
  int v19; // r10d
  unsigned int MdlAddress; // r8d
  unsigned int MdlAddress_high; // ecx
  struct _IRP *v22; // r9
  unsigned int Flags; // eax
  int v24; // r8d
  __int64 v25; // rcx
  unsigned int v26; // eax
  unsigned __int32 v27; // eax
  PVOID v28; // rax
  unsigned int v29; // [rsp+60h] [rbp+8h]

  if ( a1 )
  {
    if ( a2 )
    {
      v3 = *(_QWORD *)(a1 + 0x40);
      CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
      p_Information = &a2->IoStatus.Information;
      a2->IoStatus.Status = 0;
      a2->IoStatus.Information = 0i64;
      if ( CurrentStackLocation )
      {
        if ( v3 )
        {
          MasterIrp = a2->AssociatedIrp.MasterIrp;
          Length = CurrentStackLocation->Parameters.Read.Length;
          Options = CurrentStackLocation->Parameters.Create.Options;
          if ( !CurrentStackLocation->MajorFunction || CurrentStackLocation->MajorFunction == 2 )
            goto LABEL_27;
          if ( CurrentStackLocation->MajorFunction != 14 )
            return v29;
          LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
          if ( LowPart > 0x83002104 )
          {
            if ( LowPart == -2097143532 )
            {
              if ( (int)((__int64 (__fastcall *)(struct _IRP *, __int64, __int64))sub_122C4)(MasterIrp, Options, Length) >= 0 )
              {
LABEL_71:
                *p_Information = 8i64;
                goto LABEL_72;
              }
              goto LABEL_73;
            }
            if ( LowPart != 0x83002118 )
            {
              switch ( LowPart )
              {
                case 0x83002134:
                  if ( !*(_DWORD *)&MasterIrp->Type && (v28 = BaseAddress) != 0i64
                    || *(_DWORD *)&MasterIrp->Type == 1 && (v28 = qword_15130) != 0i64 )
                  {
                    qword_15140 = (__int64)v28;
                    v10 = 1;
                  }
                  else
                  {
                    v10 = 0;
                  }
                  goto LABEL_18;
                case 0x83002138:
                  if ( (unsigned int)((__int64 (__fastcall *)(struct _IRP *, __int64, __int64))sub_1183C)(// map primitive
                                       MasterIrp,
                                       v3,
                                       Length) )
                  {
                    *p_Information = 12i64;
                    goto LABEL_72;
                  }
                  break;
                case 0x8300213C:
                  v19 = *(_DWORD *)&MasterIrp->Type;
                  MdlAddress = (unsigned int)MasterIrp->MdlAddress;
                  MdlAddress_high = HIDWORD(MasterIrp->MdlAddress);
                  v22 = MasterIrp->AssociatedIrp.MasterIrp;
                  Flags = MasterIrp->Flags;
                  if ( *(_DWORD *)&MasterIrp->Type <= 0x100u
                    && *(_DWORD *)(&MasterIrp->Size + 1) <= 0x20u
                    && MdlAddress <= 8
                    && Flags )
                  {
                    if ( Flags > 0x400 )
                    {
                      MasterIrp->Flags = 1024;
                      Flags = 1024;
                    }
                    if ( MdlAddress_high <= 0x400 )
                    {
                      if ( MdlAddress_high <= Flags + MdlAddress_high )
                      {
                        v24 = 4
                            * (MdlAddress_high
                             + ((MdlAddress + 8 * (*(_DWORD *)(&MasterIrp->Size + 1) + 32 * (v19 + 0x8000))) << 6));
                        v25 = Flags + 1;
                        do
                        {
                          v26 = v24;
                          v24 += 4;
                          __outdword(0xCF8u, v26);
                          v27 = __indword(0xCFCu);
                          *(_DWORD *)&v22->Type = v27;
                          v22 = (struct _IRP *)((char *)v22 + 4);
                          --v25;
                        }
                        while ( v25 );
                      }
                      *p_Information = 40i64;
                      goto LABEL_72;
                    }
                  }
                  break;
                case 0x83002140:
                  v17 = (unsigned int)MasterIrp->MdlAddress;
                  if ( *(_DWORD *)&MasterIrp->Type <= 0x100u
                    && *(_DWORD *)(&MasterIrp->Size + 1) <= 0x20u
                    && v17 <= 8
                    && HIDWORD(MasterIrp->MdlAddress) <= 0x80 )
                  {
                    __outdword(
                      0xCF8u,
                      4
                    * (HIDWORD(MasterIrp->MdlAddress)
                     + ((v17 + 8 * (*(_DWORD *)(&MasterIrp->Size + 1) + 32 * (*(_DWORD *)&MasterIrp->Type + 0x8000))) << 6)));
                    v18 = __indword(0xCFCu);
                    MasterIrp->Flags = v18;
                    goto LABEL_34;
                  }
                  break;
                default:
LABEL_44:
                  a2->IoStatus.Status = sub_12EE4(
                                          v3,
                                          CurrentStackLocation->Parameters.Read.ByteOffset.LowPart,
                                          Options,
                                          Length,
                                          (__int64)MasterIrp,
                                          (__int64)MasterIrp,
                                          (__int64)p_Information);
                  goto LABEL_27;
              }
              goto LABEL_37;
            }
            v16 = sub_1174C(MasterIrp, v3);
            qword_15130 = *(PVOID *)(v3 + 112);
          }
          else
          {
            if ( LowPart != -2097143548 )
            {
              if ( LowPart != -2097143600 )
              {
                if ( LowPart != -2097143596 )
                {
                  if ( LowPart != 0x830020D8 )
                  {
                    switch ( LowPart )
                    {
                      case 0x830020F4:
                        v10 = ((__int64 (__fastcall *)(__int64, __int64, __int64))sub_11FCC)(
                                2197823748i64,
                                Options,
                                Length);
LABEL_18:
                        *p_Information = 4i64;
                        if ( v10 )
                          *(_DWORD *)&MasterIrp->Type = 1;
                        else
                          *(_DWORD *)&MasterIrp->Type = 0;
                        goto LABEL_72;
                      case 0x830020F8:
                        __outbyte(0xD808u, 0xAu);
                        v11 = __indword(0xD80Cu);
                        *(_DWORD *)(&MasterIrp->Size + 1) = BYTE1(v11);
                        *(_DWORD *)&MasterIrp->Type = BYTE2(v11);
                        break;
                      case 0x830020FC:
                        __outbyte(0xD808u, 0xAu);
                        __indword(0xD830u);
                        __outdword(0xD80Cu, 0x59490Cu);
                        break;
                      case 0x83002100:
                        v10 = ((__int64 (__fastcall *)(__int64, __int64, __int64))sub_1214C)(
                                2197823748i64,
                                Options,
                                Length);
                        goto LABEL_18;
                      default:
                        goto LABEL_44;
                    }
                    goto LABEL_71;
                  }
                  if ( (unsigned int)Length >= 4 )
                  {
                    *(_DWORD *)&MasterIrp->Type = 0x1000000;
                    *p_Information = 4i64;
LABEL_72:
                    a2->IoStatus.Status = 0;
                    goto LABEL_27;
                  }
                  a2->IoStatus.Status = -1073741811;
LABEL_27:
                  Status = a2->IoStatus.Status;
                  IofCompleteRequest(a2, 0);
                  return Status;
                }
                v14 = sub_11CA8((unsigned __int16 *)MasterIrp, Options, Length);
                if ( v14 >= 0 )
                {
                  *p_Information = 32i64 * v14;
                  goto LABEL_72;
                }
LABEL_73:
                a2->IoStatus.Status = -1073741670;
                goto LABEL_27;
              }
              v15 = BaseAddress;
              PhysicalAddress.LowPart = (DWORD)MasterIrp->MdlAddress;
              PhysicalAddress.QuadPart = PhysicalAddress.LowPart;
              *(_DWORD *)(v3 + 84) = *(_DWORD *)&MasterIrp->Type;
              *(_DWORD *)(v3 + 88) = *(_DWORD *)(&MasterIrp->Size + 1);
              if ( v15 )
              {
                MmUnmapIoSpace(v15, 0x1000000ui64);
                BaseAddress = 0i64;
              }
              ((void (__fastcall *)(_QWORD, _QWORD, _QWORD))sub_13478)(
                v3,
                (PHYSICAL_ADDRESS)PhysicalAddress.QuadPart,
                0x1000000i64);
              LODWORD(MasterIrp->MdlAddress) = PhysicalAddress.LowPart;
              HIDWORD(MasterIrp->MdlAddress) = *(_DWORD *)(v3 + 96);
              BaseAddress = *(PVOID *)(v3 + 96);
LABEL_34:
              *p_Information = 20i64;
              goto LABEL_72;
            }
            v16 = ((__int64 (__fastcall *)(struct _IRP *, __int64, __int64))sub_11B94)(MasterIrp, v3, Length);// map primitive
            qword_15128 = *(PVOID *)(v3 + 120);
          }
          if ( v16 )
            goto LABEL_34;
LABEL_37:
          a2->IoStatus.Status = -1073741823;
          goto LABEL_27;
        }
      }
    }
  }
  return 3221225473i64;
}
~~~

### IOCTL  0x83002138

This IOCTL code triggers memory map operation in function sub_1198C. You can find more memory map operation by Xref of MmMapIoSpace

~~~c
__int64 __fastcall sub_1198C(unsigned __int16 *a1, __int64 a2)
{
  unsigned __int16 v2; // di
  void *v5; // rcx
  PVOID v6; // rax
  void *v7; // rcx
  PVOID v8; // rax
  PHYSICAL_ADDRESS BusAddress; // [rsp+70h] [rbp+8h]
  LARGE_INTEGER TranslatedAddress; // [rsp+80h] [rbp+18h] BYREF

  v2 = *a1;
  if ( *a1 < 0x10u )
  {
    *(_DWORD *)(a2 + 80) = 5;
    *(_DWORD *)(a2 + 92) = 0;
    BusAddress.QuadPart = *((unsigned int *)a1 + 2);
    if ( !a1[10] )
    {
      v5 = (void *)qword_15220[v2];
      if ( v5 )
      {
        MmUnmapIoSpace(v5, 0x1000000ui64);
        qword_15220[v2] = 0i64;
        if ( !v2 )
        {
          BaseAddress = 0i64;
          qword_15140 = 0i64;
          *(_QWORD *)(a2 + 96) = 0i64;
        }
        if ( v2 == 1 )
        {
          *(_QWORD *)(a2 + 112) = 0i64;
          qword_15130 = 0i64;
        }
      }
      HalTranslateBusAddress(
        *(INTERFACE_TYPE *)(a2 + 80),
        *(_DWORD *)(a2 + 84),
        BusAddress,
        (PULONG)(a2 + 92),
        &TranslatedAddress);
      v6 = MmMapIoSpace(BusAddress, 0x1000000ui64, MmNonCached);
      qword_15220[v2] = (__int64)v6;
      *((_DWORD *)a1 + 1) = (_DWORD)v6;
      if ( !v2 )
      {
        BaseAddress = (PVOID)qword_15220[0];
        qword_15140 = qword_15220[0];
        *(_QWORD *)(a2 + 96) = qword_15220[0];
      }
      if ( v2 == 1 )
      {
        *(_QWORD *)(a2 + 112) = qword_15228;
        qword_15130 = (PVOID)qword_15228;
      }
      return 1i64;
    }
    if ( a1[10] == 1 )
    {
      v7 = (void *)qword_152E0[v2];
      if ( v7 )
      {
        MmUnmapIoSpace(v7, 0x40000ui64);
        qword_152E0[v2] = 0i64;
        if ( !v2 )
        {
          qword_15128 = 0i64;
          *(_QWORD *)(a2 + 112) = 0i64;
          qword_15138 = 0i64;
        }
      }
      HalTranslateBusAddress(
        *(INTERFACE_TYPE *)(a2 + 80),
        *(_DWORD *)(a2 + 84),
        BusAddress,
        (PULONG)(a2 + 92),
        &TranslatedAddress);
      v8 = MmMapIoSpace(BusAddress, 0x40000ui64, MmNonCached);
      qword_152E0[v2] = (__int64)v8;
      *((_DWORD *)a1 + 1) = (_DWORD)v8;
      *(_DWORD *)(a2 + 128) = 0x40000;
      if ( !v2 )
      {
        qword_15128 = (PVOID)qword_152E0[0];
        *(_QWORD *)(a2 + 112) = qword_152E0[0];
        qword_15138 = qword_152E0[0];
      }
      return 1i64;
    }
  }
  return 0i64;
}
~~~



### IOCTL  0x8300213C, 0x83002140, 0x830020F4, 0x830020F8, 0x830020FC, 0x83002100

This IOCTL  expose in/out operation on fixed io port 0xCF8,0xCFCu. There is a potential risk that may result in a Blue Screen of Death.

The operations triggered by the IO control code 0x8300213C are as follows.

```c
                case 0x8300213C:
                  v19 = *(_DWORD *)&MasterIrp->Type;
                  MdlAddress = (unsigned int)MasterIrp->MdlAddress;
                  MdlAddress_high = HIDWORD(MasterIrp->MdlAddress);
                  v22 = MasterIrp->AssociatedIrp.MasterIrp;
                  Flags = MasterIrp->Flags;
                  if ( *(_DWORD *)&MasterIrp->Type <= 0x100u
                    && *(_DWORD *)(&MasterIrp->Size + 1) <= 0x20u
                    && MdlAddress <= 8
                    && Flags )
                  {
                    if ( Flags > 0x400 )
                    {
                      MasterIrp->Flags = 1024;
                      Flags = 1024;
                    }
                    if ( MdlAddress_high <= 0x400 )
                    {
                      if ( MdlAddress_high <= Flags + MdlAddress_high )
                      {
                        v24 = 4
                            * (MdlAddress_high
                             + ((MdlAddress + 8 * (*(_DWORD *)(&MasterIrp->Size + 1) + 32 * (v19 + 0x8000))) << 6));
                        v25 = Flags + 1;
                        do
                        {
                          v26 = v24;
                          v24 += 4;
                          __outdword(0xCF8u, v26);
                          v27 = __indword(0xCFCu);
                          *(_DWORD *)&v22->Type = v27;
                          v22 = (struct _IRP *)((char *)v22 + 4);
                          --v25;
                        }
                        while ( v25 );
                      }
                      *p_Information = 40i64;
                      goto LABEL_72;
                    }
                  }
                  break;
```

