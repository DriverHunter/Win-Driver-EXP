# Vulnerable Driver ddcdrv.sys in Nicomsoft WinI2C/DDC v3.7.4.0

---

ddcdrv.sys in Nicomsoft WinI2C/DDC v3.7.4.0 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

3.7.4.0

## Vulnerability causes

ddcdrv.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

```c
__int64 __fastcall ioctler(__int64 a1, IRP *a2)
{
  __int64 v2; // r12
  unsigned int v4; // esi
  NTSTATUS v5; // ebx
  struct _IO_STACK_LOCATION *CurrentStackLocation; // r11
  unsigned int Options; // edx
  unsigned int LowPart; // eax
  unsigned int Length; // r13d
  struct _IRP *MasterIrp; // rdi
  unsigned int v11; // eax
  int v12; // ebp
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  CSHORT v19; // ax
  int v20; // eax
  unsigned __int8 v21; // al
  unsigned __int32 v22; // eax
  int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  unsigned __int32 v29; // eax
  unsigned int v30; // r8d
  unsigned __int32 v31; // eax
  __int64 v32; // rax
  __int64 v33; // rdi
  __int64 v34; // rcx
  __int64 v35; // rax
  LARGE_INTEGER MdlAddress; // rdx
  LARGE_INTEGER v37; // rcx
  bool v38; // cf
  PVOID v39; // r13
  _QWORD *v40; // rbp
  __int64 v41; // rax
  _QWORD *Pool; // rax
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  void *SectionHandle; // [rsp+50h] [rbp-A8h] BYREF
  LARGE_INTEGER BusAddress; // [rsp+58h] [rbp-A0h] BYREF
  ULONG_PTR ViewSize; // [rsp+60h] [rbp-98h] BYREF
  PVOID Object; // [rsp+68h] [rbp-90h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+70h] [rbp-88h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-78h] BYREF
  ULONG AddressSpace; // [rsp+100h] [rbp+8h] BYREF
  LARGE_INTEGER TranslatedAddress; // [rsp+108h] [rbp+10h] BYREF
  PVOID BaseAddress; // [rsp+110h] [rbp+18h] BYREF
  LARGE_INTEGER v56; // [rsp+118h] [rbp+20h] BYREF

  v2 = *(_QWORD *)(a1 + 64);
  v4 = 0;
  v5 = 0;
  KeWaitForSingleObject((PVOID)(v2 + 192), Executive, 0, 0, 0i64);
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  Options = CurrentStackLocation->Parameters.Create.Options;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  Length = CurrentStackLocation->Parameters.Read.Length;
  if ( Options || LowPart == 2236424 || LowPart == 2236432 || LowPart == 2236436 )
  {
    MasterIrp = a2->AssociatedIrp.MasterIrp;
    if ( LowPart > 0x222020 )
    {
      v24 = LowPart - 0x222024;
      if ( !v24 )
      {
        v45 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v45) = TranslatedAddress.LowPart;
        }
        __outbyte(v45, (unsigned __int8)MasterIrp->MdlAddress);// out byte primitive  IOCTL CODE 0x222024
        goto LABEL_91;
      }
      v25 = v24 - 4;
      if ( !v25 )
      {
        v44 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v44) = TranslatedAddress.LowPart;
        }
        __outword(v44, (unsigned __int16)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x222028
        goto LABEL_91;
      }
      v26 = v25 - 4;
      if ( !v26 )
      {
        v43 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v43) = TranslatedAddress.LowPart;
        }
        __outdword(v43, (unsigned int)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x22202c
        goto LABEL_91;
      }
      v27 = v26 - 4;
      if ( v27 )
      {
        v28 = v27 - 4;
        if ( !v28 )
        {
          v32 = *(_QWORD *)&MasterIrp->Type;
          v33 = *(_QWORD *)(v2 + 176);
          v34 = 0i64;
          while ( v33 )
          {
            if ( *(_QWORD *)v33 == v32 )
            {
              v35 = *(_QWORD *)(v33 + 16);
              if ( v34 )
                *(_QWORD *)(v34 + 16) = v35;
              else
                *(_QWORD *)(v2 + 176) = v35;
              ZwUnmapViewOfSection(*(HANDLE *)(v33 + 8), *(PVOID *)v33);
              ZwClose(*(HANDLE *)(v33 + 8));
              ExFreePoolWithTag((PVOID)v33, 0);
              --*(_DWORD *)(v2 + 184);
              goto LABEL_91;
            }
            v34 = v33;
            v33 = *(_QWORD *)(v33 + 16);
          }
          goto LABEL_91;
        }
        if ( v28 == 4 )
        {
          if ( Length >= 4 && Options >= 4 )
          {
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            v29 = __indword(0xCFCu);
            v30 = v29;
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            __outdword(0xCFCu, 0xFFFFFFFF);
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            v31 = __indword(0xCFCu);
            __outdword(0xCF8u, *(_DWORD *)&MasterIrp->Type);
            __outdword(0xCFCu, v30);
            v4 = 4;
            *(_DWORD *)&MasterIrp->Type = v31;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        goto LABEL_48;
      }
      if ( Length >= 4 )                        // map primitive IOCTL CODE 0x222030
      {
        MdlAddress = (LARGE_INTEGER)MasterIrp->MdlAddress;
        v37.QuadPart = MdlAddress.QuadPart + MasterIrp->Flags;
        v38 = *(_DWORD *)&MasterIrp->Type < 0xFFu;
        v56 = MdlAddress;
        BusAddress = v37;
        if ( v38 )
        {
          AddressSpace = 0;
          if ( !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, MdlAddress, &AddressSpace, &v56)
            || !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, BusAddress, &AddressSpace, &BusAddress) )
          {
            goto LABEL_36;
          }
          MdlAddress.LowPart = v56.LowPart;
          v37.LowPart = BusAddress.LowPart;
        }
        if ( v37.LowPart == MdlAddress.LowPart )
        {
          v5 = 0xC0000001;
        }
        else
        {
          RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
          ObjectAttributes.ObjectName = &DestinationString;
          ObjectAttributes.Length = 48;
          ObjectAttributes.RootDirectory = 0i64;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.SecurityDescriptor = 0i64;
          ObjectAttributes.SecurityQualityOfService = 0i64;
          if ( ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes) >= 0 )
          {
            Object = 0i64;
            ObReferenceObjectByHandle(SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
            BaseAddress = 0i64;
            TranslatedAddress = v56;
            ViewSize = MasterIrp->Flags;
            v5 = ZwMapViewOfSection(
                   SectionHandle,
                   (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                   &BaseAddress,
                   0i64,
                   MasterIrp->Flags,
                   &TranslatedAddress,
                   &ViewSize,
                   ViewShare,
                   0,
                   0x204u);
            if ( v5 >= 0 )
            {
              MasterIrp->Flags = ViewSize;
              BaseAddress = (char *)BaseAddress + v56.QuadPart - TranslatedAddress.QuadPart;
              ZwClose(SectionHandle);
              v39 = BaseAddress;
              v40 = (_QWORD *)(v2 + 176);
              v41 = *(_QWORD *)(v2 + 176);
              if ( v41 )
              {
                while ( *(_QWORD *)(v41 + 16) )
                  v41 = *(_QWORD *)(v41 + 16);
                v40 = (_QWORD *)(v41 + 16);
              }
              Pool = ExAllocatePool(NonPagedPool, 0x18ui64);
              if ( Pool )
              {
                Pool[1] = -1i64;
                Pool[2] = 0i64;
                *Pool = v39;
                *v40 = Pool;
                ++*(_DWORD *)(v2 + 184);
              }
              v4 = 8;
              *(_QWORD *)&MasterIrp->Type = BaseAddress;
            }
            else
            {
              ZwClose(SectionHandle);
            }
          }
          else
          {
            v5 = 0xC0000008;
          }
        }
        goto LABEL_91;
      }
LABEL_36:
      v5 = -1073741811;
      goto LABEL_91;
    }
    if ( LowPart == 0x222020 )
    {
      v12 = 4;
      if ( Length < 4 )
        goto LABEL_36;
      v23 = *(_DWORD *)(&MasterIrp->Size + 1);
      if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
      {
        AddressSpace = 1;
        if ( !HalTranslateBusAddress(
                PCIBus,
                *(_DWORD *)&MasterIrp->Type,
                (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                &AddressSpace,
                &TranslatedAddress) )
          goto LABEL_36;
        LOWORD(v23) = TranslatedAddress.LowPart;
      }
      v22 = __indword(v23);                     // in dword primitive IOCTL CODE 0X222020
    }
    else
    {
      v11 = LowPart - 0x222004;
      if ( !v11 )
      {
        v12 = 280;
        if ( Length < 0x118 || Options < 0x118 )
          goto LABEL_36;
        v5 = sub_11534(v2, (__int64)a2->AssociatedIrp.MasterIrp);
LABEL_35:
        v4 = v12;
        goto LABEL_91;
      }
      v12 = 4;
      v13 = v11 - 4;
      if ( v13 )
      {
        v14 = v13 - 4;
        if ( !v14 )
        {
          if ( Options >= 4 )
          {
            *(_DWORD *)(v2 + 188) = *(_DWORD *)&MasterIrp->Type;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        v15 = v14 - 4;
        if ( v15 )
        {
          v16 = v15 - 4;
          if ( !v16 )
          {
            sub_1104C(v2);
            goto LABEL_91;
          }
          v17 = v16 - 4;
          if ( v17 )
          {
            if ( v17 == 4 )
            {
              if ( Length >= 2 )
              {
                v18 = *(_DWORD *)(&MasterIrp->Size + 1);
                if ( *(_DWORD *)&MasterIrp->Type >= 0xFFu )
                {
LABEL_19:
                  v19 = __inword(v18);          // in word primitive IOCTL CODE 0X22201C
                  MasterIrp->Type = v19;
                  v4 = 2;
LABEL_91:
                  KeReleaseMutex((PRKMUTEX)(v2 + 192), 0);
                  a2->IoStatus.Information = v4;
                  goto LABEL_92;
                }
                AddressSpace = 1;
                if ( HalTranslateBusAddress(
                       PCIBus,
                       *(_DWORD *)&MasterIrp->Type,
                       (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                       &AddressSpace,
                       &TranslatedAddress) )
                {
                  LOWORD(v18) = TranslatedAddress.LowPart;
                  goto LABEL_19;
                }
              }
              goto LABEL_36;
            }
LABEL_48:
            v5 = -1073741808;
            goto LABEL_91;
          }
          if ( Length )
          {
            v20 = *(_DWORD *)(&MasterIrp->Size + 1);
            if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
            {
              AddressSpace = 1;
              if ( !HalTranslateBusAddress(
                      PCIBus,
                      *(_DWORD *)&MasterIrp->Type,
                      (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                      &AddressSpace,
                      &TranslatedAddress) )
                goto LABEL_36;
              LOWORD(v20) = TranslatedAddress.LowPart;
            }
            v21 = __inbyte(v20);                // in byte primitive IOCTL CODE 0X222018
            LOBYTE(MasterIrp->Type) = v21;
            v4 = 1;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        sub_110C4(v2);
      }
      if ( Length < 4 )
        goto LABEL_36;
      v22 = *(_DWORD *)(v2 + 168);
    }
    *(_DWORD *)&MasterIrp->Type = v22;
    goto LABEL_35;
  }
  KeReleaseMutex((PRKMUTEX)(v2 + 192), 0);
  v5 = -1073741808;
  a2->IoStatus.Information = 0i64;
LABEL_92:
  a2->IoStatus.Status = v5;
  IofCompleteRequest(a2, 0);
  return (unsigned int)v5;
}
```

### IOCTL  0x222024(out byte), 0x222028(out word), 0x22202c(out dword)

This IOCTL code triggers port out operation as blow. 

~~~c
   if ( LowPart > 0x222020 )
    {
      v24 = LowPart - 0x222024;
      if ( !v24 )
      {
        v45 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v45) = TranslatedAddress.LowPart;
        }
        __outbyte(v45, (unsigned __int8)MasterIrp->MdlAddress);// out byte primitive  IOCTL CODE 0x222024
        goto LABEL_91;
      }
      v25 = v24 - 4;
      if ( !v25 )
      {
        v44 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v44) = TranslatedAddress.LowPart;
        }
        __outword(v44, (unsigned __int16)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x222028
        goto LABEL_91;
      }
      v26 = v25 - 4;
      if ( !v26 )
      {
        v43 = *(_DWORD *)(&MasterIrp->Size + 1);
        if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
        {
          AddressSpace = 1;
          if ( !HalTranslateBusAddress(
                  PCIBus,
                  *(_DWORD *)&MasterIrp->Type,
                  (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                  &AddressSpace,
                  &TranslatedAddress) )
            goto LABEL_36;
          LOWORD(v43) = TranslatedAddress.LowPart;
        }
        __outdword(v43, (unsigned int)MasterIrp->MdlAddress);// out word primitive IOCTL CODE 0x22202c
        goto LABEL_91;
      }
~~~

### IOCTL  0x222030

This IOCTL code triggers memory mapping operation as blow. 

~~~c
     if ( Length >= 4 )                        // map primitive IOCTL CODE 0x222030
      {
        MdlAddress = (LARGE_INTEGER)MasterIrp->MdlAddress;
        v37.QuadPart = MdlAddress.QuadPart + MasterIrp->Flags;
        v38 = *(_DWORD *)&MasterIrp->Type < 0xFFu;
        v56 = MdlAddress;
        BusAddress = v37;
        if ( v38 )
        {
          AddressSpace = 0;
          if ( !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, MdlAddress, &AddressSpace, &v56)
            || !HalTranslateBusAddress(PCIBus, *(_DWORD *)&MasterIrp->Type, BusAddress, &AddressSpace, &BusAddress) )
          {
            goto LABEL_36;
          }
          MdlAddress.LowPart = v56.LowPart;
          v37.LowPart = BusAddress.LowPart;
        }
        if ( v37.LowPart == MdlAddress.LowPart )
        {
          v5 = 0xC0000001;
        }
        else
        {
          RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
          ObjectAttributes.ObjectName = &DestinationString;
          ObjectAttributes.Length = 48;
          ObjectAttributes.RootDirectory = 0i64;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.SecurityDescriptor = 0i64;
          ObjectAttributes.SecurityQualityOfService = 0i64;
          if ( ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes) >= 0 )
          {
            Object = 0i64;
            ObReferenceObjectByHandle(SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
            BaseAddress = 0i64;
            TranslatedAddress = v56;
            ViewSize = MasterIrp->Flags;
            v5 = ZwMapViewOfSection(
                   SectionHandle,
                   (HANDLE)0xFFFFFFFFFFFFFFFFi64,
                   &BaseAddress,
                   0i64,
                   MasterIrp->Flags,
                   &TranslatedAddress,
                   &ViewSize,
                   ViewShare,
                   0,
                   0x204u);
            if ( v5 >= 0 )
            {
              MasterIrp->Flags = ViewSize;
              BaseAddress = (char *)BaseAddress + v56.QuadPart - TranslatedAddress.QuadPart;
              ZwClose(SectionHandle);
              v39 = BaseAddress;
              v40 = (_QWORD *)(v2 + 176);
              v41 = *(_QWORD *)(v2 + 176);
              if ( v41 )
              {
                while ( *(_QWORD *)(v41 + 16) )
                  v41 = *(_QWORD *)(v41 + 16);
                v40 = (_QWORD *)(v41 + 16);
              }
              Pool = ExAllocatePool(NonPagedPool, 0x18ui64);
              if ( Pool )
              {
                Pool[1] = -1i64;
                Pool[2] = 0i64;
                *Pool = v39;
                *v40 = Pool;
                ++*(_DWORD *)(v2 + 184);
              }
              v4 = 8;
              *(_QWORD *)&MasterIrp->Type = BaseAddress;
            }
            else
            {
              ZwClose(SectionHandle);
            }
          }
          else
          {
            v5 = 0xC0000008;
          }
        }
        goto LABEL_91;
      }
~~~

### IOCTL  0x222018(in byte),0x22201C(in word), 0x222020(in dword)

This IOCTL code triggers port in operation as blow. 

~~~c
   if ( LowPart == 0x222020 )
    {
      v12 = 4;
      if ( Length < 4 )
        goto LABEL_36;
      v23 = *(_DWORD *)(&MasterIrp->Size + 1);
      if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
      {
        AddressSpace = 1;
        if ( !HalTranslateBusAddress(
                PCIBus,
                *(_DWORD *)&MasterIrp->Type,
                (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                &AddressSpace,
                &TranslatedAddress) )
          goto LABEL_36;
        LOWORD(v23) = TranslatedAddress.LowPart;
      }
      v22 = __indword(v23);                     // in dword primitive IOCTL CODE 0X222020
    }
    else
    {
      v11 = LowPart - 0x222004;
      if ( !v11 )
      {
        v12 = 280;
        if ( Length < 0x118 || Options < 0x118 )
          goto LABEL_36;
        v5 = sub_11534(v2, (__int64)a2->AssociatedIrp.MasterIrp);
LABEL_35:
        v4 = v12;
        goto LABEL_91;
      }
      v12 = 4;
      v13 = v11 - 4;
      if ( v13 )
      {
        v14 = v13 - 4;
        if ( !v14 )
        {
          if ( Options >= 4 )
          {
            *(_DWORD *)(v2 + 188) = *(_DWORD *)&MasterIrp->Type;
            goto LABEL_91;
          }
          goto LABEL_36;
        }
        v15 = v14 - 4;
        if ( v15 )
        {
          v16 = v15 - 4;
          if ( !v16 )
          {
            sub_1104C(v2);
            goto LABEL_91;
          }
          v17 = v16 - 4;
          if ( v17 )
          {
            if ( v17 == 4 )
            {
              if ( Length >= 2 )
              {
                v18 = *(_DWORD *)(&MasterIrp->Size + 1);
                if ( *(_DWORD *)&MasterIrp->Type >= 0xFFu )
                {
LABEL_19:
                  v19 = __inword(v18);          // in word primitive IOCTL CODE 0X22201C
                  MasterIrp->Type = v19;
                  v4 = 2;
LABEL_91:
                  KeReleaseMutex((PRKMUTEX)(v2 + 192), 0);
                  a2->IoStatus.Information = v4;
                  goto LABEL_92;
                }
                AddressSpace = 1;
                if ( HalTranslateBusAddress(
                       PCIBus,
                       *(_DWORD *)&MasterIrp->Type,
                       (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                       &AddressSpace,
                       &TranslatedAddress) )
                {
                  LOWORD(v18) = TranslatedAddress.LowPart;
                  goto LABEL_19;
                }
              }
              goto LABEL_36;
            }
LABEL_48:
            v5 = -1073741808;
            goto LABEL_91;
          }
          if ( Length )
          {
            v20 = *(_DWORD *)(&MasterIrp->Size + 1);
            if ( *(_DWORD *)&MasterIrp->Type < 0xFFu )
            {
              AddressSpace = 1;
              if ( !HalTranslateBusAddress(
                      PCIBus,
                      *(_DWORD *)&MasterIrp->Type,
                      (PHYSICAL_ADDRESS)*(unsigned int *)(&MasterIrp->Size + 1),
                      &AddressSpace,
                      &TranslatedAddress) )
                goto LABEL_36;
              LOWORD(v20) = TranslatedAddress.LowPart;
            }
            v21 = __inbyte(v20);                // in byte primitive IOCTL CODE 0X222018
            LOBYTE(MasterIrp->Type) = v21;
            v4 = 1;
            goto LABEL_91;
          }
~~~

