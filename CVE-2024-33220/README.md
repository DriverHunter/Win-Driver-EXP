# Vulnerable Driver AslO3_64.sys in ASUS AISuite3 v3.03.36 3.03.36

---

Many vulnerability exits in driver AslO3_64.sys, which allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port and even read/write arbitary MSR via specially crafted IOCTL requests . This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  



## version

3.03.36

## Vulnerability causes

AslO3_64.sys provides the functionality of mapping physical memory and read/write I/O ports and arbitrary read/write MSR, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_140001930(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  __int64 v4; // rcx
  __int64 v5; // r9
  int v6; // r14d
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdx
  void **DeviceExtension; // rdi
  struct _IRP *MasterIrp; // r12
  unsigned int Options; // r13d
  __int64 Length; // r8
  signed int Status; // esi
  UCHAR MajorFunction; // al
  unsigned int LowPart; // ecx
  struct _IRP *v15; // r8
  unsigned __int16 MdlAddress; // dx
  struct _IRP *v17; // rdx
  char v18; // al
  unsigned __int8 v19; // al
  unsigned __int16 v20; // dx
  unsigned int MdlAddress_high; // eax
  unsigned __int16 v22; // dx
  char v23; // al
  unsigned __int32 v24; // eax
  unsigned __int32 v25; // eax
  unsigned __int16 v26; // dx
  struct _IRP *v27; // r8
  char v28; // al
  char Type; // al
  unsigned __int32 v30; // eax
  struct _IRP *v31; // r8
  struct _IRP *v32; // r8
  unsigned __int16 v33; // cx
  _BYTE *v34; // r9
  unsigned __int8 v35; // al
  struct _IRP *v36; // r8
  unsigned __int16 v37; // cx
  _BYTE *v38; // r9
  unsigned __int8 v39; // al
  struct _IRP *v40; // rcx
  unsigned __int16 v41; // dx
  __int64 v42; // r8
  unsigned __int32 v43; // eax
  struct _IRP *v44; // rbx
  ULONG v45; // edx
  ULONG v46; // r9d
  char v47; // al
  int Flags_low; // eax
  struct _IRP *v49; // r12
  ULONG BusDataByOffset; // eax
  int Type_low; // edx
  void *v52; // rcx
  SIZE_T Flags; // rax
  SIZE_T v54; // rdi
  __int64 result; // rax
  struct _IRP *v56; // rdi
  ULONG_PTR v57; // rbx
  unsigned int v58; // ebx
  unsigned int v59; // ebx
  struct _IRP *v60; // r10
  __int64 v61; // r8
  NTSTATUS v62; // eax
  struct _IRP *v63; // r10
  __int64 v64; // r8
  unsigned __int16 v65; // bx
  int v66; // eax
  PVOID ContiguousMemory; // rax
  __int64 v68; // rdi
  DWORD v69; // ebx
  _QWORD *PoolWithTag; // rax
  __int64 v71; // rcx
  int v72; // eax
  PKEVENT v73; // rax
  struct _UNICODE_STRING Buffer; // [rsp+30h] [rbp-88h] BYREF
  __int64 v75; // [rsp+40h] [rbp-78h]
  int v76; // [rsp+48h] [rbp-70h]
  __int16 v77[2]; // [rsp+50h] [rbp-68h] BYREF
  unsigned int v78; // [rsp+54h] [rbp-64h]
  char v79; // [rsp+58h] [rbp-60h]
  __m128i v80; // [rsp+60h] [rbp-58h] BYREF
  HANDLE Handle[2]; // [rsp+70h] [rbp-48h]
  PVOID Flink; // [rsp+80h] [rbp-38h] BYREF

  *(_QWORD *)&Buffer.Length = Irp;
  LOBYTE(v5) = IoIs32bitProcess(Irp);
  v6 = 0;
  Irp->IoStatus.Information = 0i64;
  CurrentStackLocation = Irp->Tail.Overlay.CurrentStackLocation;
  DeviceExtension = (void **)DeviceObject->DeviceExtension;
  MasterIrp = Irp->AssociatedIrp.MasterIrp;
  Options = CurrentStackLocation->Parameters.Create.Options;
  Length = CurrentStackLocation->Parameters.Read.Length;
  Status = -1073741822;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( !CurrentStackLocation->MajorFunction )
  {
    if ( !DeviceExtension[6] )
    {
      RtlInitUnicodeString(&Buffer, L"\\BaseNamedObjects\\WaitForIoAccess");
      v73 = IoCreateSynchronizationEvent(&Buffer, DeviceExtension + 6);
      DeviceExtension[5] = v73;
      if ( !v73 )
      {
        IoDeleteDevice(DeviceObject);
        return 3221225473i64;
      }
    }
    if ( !(unsigned __int8)sub_140002F54(v4, CurrentStackLocation, Length, v5) )
    {
      Status = 0;
      if ( (int)sub_140003218() < 0 )
        Status = -1073741790;
      goto LABEL_193;
    }
    sub_140002BA4();
    goto LABEL_192;
  }
  if ( MajorFunction == 2 )
  {
    v62 = sub_140003AF4(v4, CurrentStackLocation, Length, v5);
    goto LABEL_169;
  }
  if ( MajorFunction != 14 )
    goto LABEL_193;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  if ( LowPart > 0xA0402014 )
  {
    if ( LowPart > 0xA040A45C )
    {
      if ( LowPart != -1606376352 )
      {
        if ( LowPart == -1606376348 )
        {
          v72 = sub_1400016B4(Irp, CurrentStackLocation, Length, v5);
          goto LABEL_180;
        }
        if ( LowPart == 0xA040A480 )            // map primitive
        {
LABEL_174:
          if ( !(_BYTE)v5 )
          {
            if ( Options == 40 )
            {
              v80 = *(__m128i *)&MasterIrp->Type;
              *(_OWORD *)Handle = *(_OWORD *)&MasterIrp->Flags;
              Flink = MasterIrp->ThreadListEntry.Flink;
              Status = ((__int64 (__usercall *)@<rax>(PHYSICAL_ADDRESS@<rcx>, PVOID *))sub_140003538)(
                         (PHYSICAL_ADDRESS)_mm_srli_si128(v80, 8).m128i_i64[0],
                         &Flink);
              if ( Status >= 0 )
              {
                *(__m128i *)&MasterIrp->Type = v80;
                *(_OWORD *)&MasterIrp->Flags = *(_OWORD *)Handle;
                MasterIrp->ThreadListEntry.Flink = (struct _LIST_ENTRY *)Flink;
                Irp->IoStatus.Information = 40i64;
              }
              goto LABEL_193;
            }
            goto LABEL_154;
          }
          v72 = sub_140003268((__int64)DeviceObject, (__int64)Irp, (__int64)Irp->Tail.Overlay.CurrentStackLocation, v5);
LABEL_180:
          Status = v72;
          if ( v72 >= 0 )
            Irp->IoStatus.Information = 4i64;
          goto LABEL_193;
        }
        if ( LowPart == -1606376312 )
        {
          if ( *(_DWORD *)&MasterIrp->Type > 0x8000000u )
            goto LABEL_154;
          ContiguousMemory = MmAllocateContiguousMemory(
                               *(unsigned int *)&MasterIrp->Type,
                               (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
          v68 = (unsigned int)ContiguousMemory;
          *(_DWORD *)(&Buffer.MaximumLength + 1) = (_DWORD)ContiguousMemory;
          v69 = MmGetPhysicalAddress(ContiguousMemory).LowPart;
          *(_DWORD *)&Buffer.Length = v69;
          PoolWithTag = ExAllocatePoolWithTag(PagedPool, 0x20ui64, 0x705052u);
          PoolWithTag[2] = v68;
          PoolWithTag[3] = v69;
          v71 = qword_1400093F0;
          if ( *(__int64 **)(qword_1400093F0 + 8) != &qword_1400093F0 )
            __fastfail(3u);
          *PoolWithTag = qword_1400093F0;
          PoolWithTag[1] = &qword_1400093F0;
          *(_QWORD *)(v71 + 8) = PoolWithTag;
          qword_1400093F0 = (__int64)PoolWithTag;
          *(_QWORD *)&MasterIrp->Type = *(_QWORD *)&Buffer.Length;
          Irp->IoStatus.Information = 8i64;
        }
        else if ( LowPart != 0xA040A48C )
        {
          if ( LowPart == 0xA040A490 )
          {
            v62 = ((__int64 (__fastcall *)(PIRP, struct _IO_STACK_LOCATION *, __int64, __int64))sub_140003AB0)(
                    Irp,
                    CurrentStackLocation,
                    Length,
                    v5);
          }
          else
          {
            if ( ((LowPart + 1606376128) & 0xFFFFFFF3) != 0 || LowPart == -1606376116 )
              goto LABEL_193;
            LOBYTE(Length) = v5;
            v62 = sub_140002918(Irp, CurrentStackLocation, Length);
          }
          goto LABEL_169;
        }
LABEL_192:
        Status = 0;
        goto LABEL_193;
      }
      v66 = ((__int64 (__fastcall *)(PIRP, struct _IO_STACK_LOCATION *, __int64, __int64))sub_140003B4C)(
              Irp,
              CurrentStackLocation,
              Length,
              v5);
    }
    else if ( LowPart == 0xA040A45C )
    {
      v66 = sub_140003DE8((__int64)Irp, (__int64)CurrentStackLocation, Length, v5);
    }
    else
    {
      if ( LowPart <= 0xA0406408 )
      {
        if ( LowPart == 0xA0406408 )
        {
LABEL_129:
          LOBYTE(Length) = v5;
          v62 = ((__int64 (__fastcall *)(PIRP, struct _IO_STACK_LOCATION *, __int64))sub_140002654)(// in primitive
                  Irp,
                  CurrentStackLocation,
                  Length);
          goto LABEL_169;
        }
        if ( LowPart == -1606410216 )
        {
          Status = 0;
          KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
          v63 = Irp->AssociatedIrp.MasterIrp;
          LOBYTE(v64) = v63->Type;
          if ( ((LOBYTE(v63->Type) - 1) & 0xFC) == 0 && (_BYTE)v64 != 3 && Options >= 0x23 )
          {
            sub_1400010F0(
              *(CSHORT *)((char *)&v63->Type + 1),
              *(_DWORD *)((char *)&v63->Size + 1),
              v64,
              (unsigned int *)((char *)&v63->Size + 5));
            Irp->IoStatus.Information = 35i64;
            goto LABEL_92;
          }
          goto LABEL_91;
        }
        if ( LowPart != 0xA040244C )
        {
          if ( LowPart != 0xA0402450 )
          {
            if ( ((LowPart + 0x5FBF9C00) & 0xFFFFFFFB) != 0 )
              goto LABEL_193;
            goto LABEL_129;
          }
          if ( (_BYTE)v5 )
          {
            if ( Options < 4 )
            {
              Status = 0xC000009A;
              goto LABEL_193;
            }
            v62 = ZwUnmapViewOfSection((HANDLE)0xFFFFFFFFFFFFFFFFi64, (PVOID)*(unsigned int *)&MasterIrp->Type);
LABEL_169:
            Status = v62;
            goto LABEL_193;
          }
          if ( Options )
          {
            sub_140007380(
              &v80,
              (unsigned __int64)Irp->AssociatedIrp.MasterIrp,
              CurrentStackLocation->Parameters.Create.Options);
            v62 = sub_140003BA8(Handle[0]);
            goto LABEL_169;
          }
LABEL_154:
          Status = -1073741811;
          goto LABEL_193;
        }
        goto LABEL_174;
      }
      if ( LowPart != 0xA0406458 )
      {
        if ( ((LowPart + 0x5FBF5BC0) & 0xFFFFFFF3) != 0 || LowPart == 0xA040A44C )
          goto LABEL_193;
        if ( (_BYTE)v5 )
        {
          LOBYTE(Length) = v5;
          v62 = sub_140002774((__int64)Irp, (__int64)CurrentStackLocation, Length);// out primitive
          goto LABEL_169;
        }
        if ( !Options )
          goto LABEL_154;
        sub_140007380(
          (__m128i *)v77,
          (unsigned __int64)Irp->AssociatedIrp.MasterIrp,
          CurrentStackLocation->Parameters.Create.Options);
        v65 = v77[0];
        if ( (unsigned int)sub_14000130C((unsigned __int16)v77[0]) )
          return 3221225506i64;
        switch ( v79 )
        {
          case 1:
            __outbyte(v65, v78);
            break;
          case 2:
            __outword(v65, v78);
            break;
          case 4:
            __outdword(v65, v78);
            break;
        }
        goto LABEL_192;
      }
      v66 = sub_1400039D0((__int64)Irp, (__int64)CurrentStackLocation, Length, v5);
    }
    Status = v66;
    if ( v66 >= 0 )
      Irp->IoStatus.Information = 8i64;
    goto LABEL_193;
  }
  if ( LowPart == -1606410220 )
  {
    Status = 0;
    KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
    v60 = Irp->AssociatedIrp.MasterIrp;
    LOBYTE(v61) = v60->Type;
    if ( ((LOBYTE(v60->Type) - 1) & 0xFC) == 0 && (_BYTE)v61 != 3 && Options >= 0x23 )
    {
      Buffer = *(struct _UNICODE_STRING *)((char *)&v60->Size + 5);
      v75 = *(_QWORD *)((char *)&v60->Flags + 7);
      v76 = *(_DWORD *)((char *)&v60->AssociatedIrp.SystemBuffer + 7);
      ((void (__fastcall *)(_QWORD, _QWORD, __int64, struct _UNICODE_STRING *))sub_140001000)(// out primitive
        *(unsigned __int16 *)((char *)&v60->Type + 1),
        *(unsigned int *)((char *)&v60->Size + 1),
        v61,
        &Buffer);
      goto LABEL_92;
    }
    goto LABEL_91;
  }
  if ( LowPart <= 0xA0400F80 )
  {
    if ( LowPart == -1606414464 )
    {
      sub_140004264(Irp, Options, Length, v5);
    }
    else
    {
      if ( LowPart <= 0xA0400F6C )
      {
        switch ( LowPart )
        {
          case 0xA0400F6C:
            Status = 0;
            KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
            v31 = Irp->AssociatedIrp.MasterIrp;
            if ( LOBYTE(v31->Type) != 1 )
              goto LABEL_91;
            __outbyte((unsigned __int16)v31->MdlAddress, BYTE2(v31->MdlAddress));
            v19 = BYTE2(v31->Flags);
            v20 = LOWORD(v31->MdlAddress) + 1;
            goto LABEL_19;
          case 0xA0400F58:
            Status = 0;
            KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
            v15 = Irp->AssociatedIrp.MasterIrp;
            __outdword(0xCF8u, *(_DWORD *)(&v15->Size + 1));
            Type = v15->Type;
            if ( LOBYTE(v15->Type) == 1 )
            {
              v24 = __indword(0xCFCu);
              goto LABEL_39;
            }
            if ( Type == 2 )
            {
              v25 = __indword(0xCFCu);
              goto LABEL_42;
            }
            if ( Type != 4 )
              goto LABEL_91;
            v26 = 3324;
            break;
          case 0xA0400F5C:
            Status = 0;
            KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
            v27 = Irp->AssociatedIrp.MasterIrp;
            __outdword(0xCF8u, *(_DWORD *)(&v27->Size + 1));
            v22 = 3324;
            __indword(0xCFCu);
            v28 = v27->Type;
            if ( LOBYTE(v27->Type) == 1 || v28 == 2 )
            {
              MdlAddress_high = 0;
            }
            else
            {
              if ( v28 != 4 )
                goto LABEL_91;
              MdlAddress_high = HIDWORD(v27->MdlAddress);
            }
            goto LABEL_36;
          case 0xA0400F60:
            Status = 0;
            KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
            v15 = Irp->AssociatedIrp.MasterIrp;
            v23 = v15->Type;
            if ( LOBYTE(v15->Type) == 1 )
            {
              MdlAddress = (unsigned __int16)v15->MdlAddress;
              goto LABEL_26;
            }
            if ( v23 == 2 )
            {
              LOWORD(v25) = __inword((unsigned __int16)v15->MdlAddress);// in word
LABEL_42:
              LOWORD(v15->Flags) = v25;
              goto LABEL_46;
            }
            if ( v23 != 4 )
              goto LABEL_91;
            v26 = (unsigned __int16)v15->MdlAddress;
            break;
          case 0xA0400F64:
            Status = 0;
            KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
            v17 = Irp->AssociatedIrp.MasterIrp;
            v18 = v17->Type;
            if ( LOBYTE(v17->Type) == 1 )
            {
              v19 = BYTE2(v17->Flags);
              v20 = (unsigned __int16)v17->MdlAddress;
LABEL_19:
              __outbyte(v20, v19);
LABEL_92:
              KeSetEvent((PRKEVENT)DeviceExtension[5], 0, 0);
              goto LABEL_193;
            }
            if ( v18 == 2 )
            {
              __outword((unsigned __int16)v17->MdlAddress, v17->Flags);
              goto LABEL_92;
            }
            if ( v18 != 4 )
              goto LABEL_91;
            MdlAddress_high = HIDWORD(v17->MdlAddress);
            v22 = (unsigned __int16)v17->MdlAddress;
LABEL_36:
            __outdword(v22, MdlAddress_high);
            goto LABEL_92;
          case 0xA0400F68:
            Status = 0;
            KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
            v15 = Irp->AssociatedIrp.MasterIrp;
            if ( LOBYTE(v15->Type) == 1 )
            {
              __outbyte((unsigned __int16)v15->MdlAddress, BYTE2(v15->MdlAddress));
              MdlAddress = LOWORD(v15->MdlAddress) + 1;
LABEL_26:
              LOBYTE(v24) = __inbyte(MdlAddress);
LABEL_39:
              BYTE2(v15->Flags) = v24;
LABEL_46:
              Irp->IoStatus.Information = 20i64;
              goto LABEL_92;
            }
LABEL_91:
            Status = -1073741811;
            goto LABEL_92;
          default:
LABEL_193:
            Irp->IoStatus.Status = Status;
            IofCompleteRequest(Irp, 0);
            return (unsigned int)Status;
        }
        v30 = __indword(v26);
        HIDWORD(v15->MdlAddress) = v30;
        goto LABEL_46;
      }
      switch ( LowPart )
      {
        case 0xA0400F70:
          Status = 0;
          KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
          v40 = Irp->AssociatedIrp.MasterIrp;
          v41 = (unsigned __int16)v40->MdlAddress;
          if ( v41 <= 0x200u )
          {
            if ( v41 )
            {
              v42 = 0i64;
              do
              {
                __outdword(0xCF8u, *(_DWORD *)&v40->Type);
                v43 = __indword(0xCFCu);
                *(_DWORD *)((char *)&v40->MdlAddress + v42 + 2) = v43;
                *(_DWORD *)&v40->Type += 4;
                Irp->IoStatus.Information = 524i64;
                v6 += 4;
                v42 += 4i64;
              }
              while ( v6 < LOWORD(v40->MdlAddress) );
            }
            goto LABEL_92;
          }
          goto LABEL_91;
        case 0xA0400F74:
          Status = 0;
          KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
          v36 = Irp->AssociatedIrp.MasterIrp;
          v37 = (unsigned __int16)v36->MdlAddress;
          if ( v37 <= 0x200u )
          {
            if ( v37 )
            {
              v38 = (char *)&v36->MdlAddress + 2;
              do
              {
                v39 = __inbyte(*(&v36->Size + 1));
                *v38 = v39;
                ++*(&v36->Size + 1);
                Irp->IoStatus.Information = 524i64;
                ++v6;
                ++v38;
              }
              while ( v6 < LOWORD(v36->MdlAddress) );
            }
            goto LABEL_92;
          }
          goto LABEL_91;
        case 0xA0400F78:
          Status = 0;
          KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
          v32 = Irp->AssociatedIrp.MasterIrp;
          v33 = (unsigned __int16)v32->MdlAddress;
          if ( v33 <= 0x200u && v33 )
          {
            v34 = (char *)&v32->MdlAddress + 2;
            do
            {
              __outbyte(*(&v32->Size + 1), *((_BYTE *)&v32->Size + 4));
              v35 = __inbyte(*(&v32->Size + 1) + 1);
              *v34 = v35;
              ++*((_BYTE *)&v32->Size + 4);
              Irp->IoStatus.Information = 524i64;
              ++v6;
              ++v34;
            }
            while ( v6 < LOWORD(v32->MdlAddress) );
          }
          goto LABEL_92;
      }
      if ( LowPart != -1606414468 )
        goto LABEL_193;
      sub_140004158(Irp, Options, Length, v5);
    }
LABEL_54:
    Status = Irp->IoStatus.Status;
    goto LABEL_193;
  }
  switch ( LowPart )
  {
    case 0xA0400F84:
      sub_140003FEC(Irp, Options, Length, v5);
      goto LABEL_54;
    case 0xA0400F88:
      v59 = *(_DWORD *)&MasterIrp->Type;
      Status = (unsigned int)((__int64 (__fastcall *)(_QWORD, struct _IO_STACK_LOCATION *, __int64, __int64))sub_14000138C)(
                               *(unsigned int *)&MasterIrp->Type,
                               CurrentStackLocation,
                               Length,
                               v5) != 0
             ? 0xC0000022
             : 0;
      MasterIrp->MdlAddress = (PMDL)__readmsr(v59);// rdmsr
      Irp->IoStatus.Information = 16i64;
      goto LABEL_193;
    case 0xA0400F8C:
      v58 = *(_DWORD *)&MasterIrp->Type;
      Status = (unsigned int)((__int64 (__fastcall *)(_QWORD, struct _IO_STACK_LOCATION *, __int64, __int64))sub_14000138C)(
                               *(unsigned int *)&MasterIrp->Type,
                               CurrentStackLocation,
                               Length,
                               v5) != 0
             ? 0xC0000022
             : 0;
      __writemsr(v58, (unsigned __int64)MasterIrp->MdlAddress);// wrmsr
      goto LABEL_193;
  }
  if ( LowPart != 0xA0400F90 )
  {
    if ( LowPart == 0xA0400F94 )
    {
      Status = 0;
      if ( Options == 0x1020 )
        v52 = MasterIrp->AssociatedIrp.MasterIrp;
      else
        v52 = MasterIrp->ThreadListEntry.Flink;
      MmFreeContiguousMemory(v52);
      goto LABEL_193;
    }
    if ( LowPart == -1606410240 )
    {
      Status = 0;
      KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
      v49 = Irp->AssociatedIrp.MasterIrp;
      *(_DWORD *)&Buffer.Length = 0;
      BusDataByOffset = HalGetBusDataByOffset(
                          PCIConfiguration,
                          *((unsigned __int8 *)&v49->Size + 4),
                          (*(_DWORD *)(&v49->Size + 1) & 0x700 | (*(_DWORD *)(&v49->Size + 1) >> 8) & 0xF8u) >> 3,
                          &Buffer,
                          (unsigned __int8)*(_DWORD *)(&v49->Size + 1),
                          LOBYTE(v49->Type));
      Type_low = LOBYTE(v49->Type);
      if ( BusDataByOffset != Type_low )
      {
        *(_DWORD *)&Buffer.Length = -1;
        LOBYTE(Type_low) = v49->Type;
      }
      switch ( (_BYTE)Type_low )
      {
        case 1:
          BYTE2(v49->Flags) = Buffer.Length;
          break;
        case 2:
          LOWORD(v49->Flags) = Buffer.Length;
          break;
        case 4:
          HIDWORD(v49->MdlAddress) = *(_DWORD *)&Buffer.Length;
          break;
        default:
          Status = 0xC000000D;
          break;
      }
      goto LABEL_46;
    }
    if ( LowPart != 0xA0402004 )
    {
      if ( LowPart != 0xA040200C )
      {
        if ( LowPart == 0xA0402010 )
        {
          Status = sub_140003FB8(MasterIrp->MdlAddress);
          Irp->IoStatus.Information = 0i64;
        }
        goto LABEL_193;
      }
      sub_1400040C4(Irp, Options, Length, v5);
      goto LABEL_54;
    }
    Status = 0;
    KeWaitForSingleObject(DeviceExtension[5], Executive, 0, 0, 0i64);
    v44 = Irp->AssociatedIrp.MasterIrp;
    *(_DWORD *)&Buffer.Length = 0;
    v45 = *((unsigned __int8 *)&v44->Size + 4);
    v46 = (unsigned __int8)*(_DWORD *)(&v44->Size + 1);
    v47 = v44->Type;
    if ( LOBYTE(v44->Type) == 1 )
    {
      Flags_low = BYTE2(v44->Flags);
    }
    else if ( v47 == 2 )
    {
      Flags_low = LOWORD(v44->Flags);
    }
    else
    {
      if ( v47 != 4 )
      {
        Status = -1073741811;
LABEL_90:
        if ( HalSetBusDataByOffset(
               PCIConfiguration,
               v45,
               (*(_DWORD *)(&v44->Size + 1) & 0x700 | (*(_DWORD *)(&v44->Size + 1) >> 8) & 0xF8u) >> 3,
               &Buffer,
               v46,
               LOBYTE(v44->Type)) == LOBYTE(v44->Type) )
          goto LABEL_46;
        goto LABEL_91;
      }
      Flags_low = HIDWORD(v44->MdlAddress);
    }
    *(_DWORD *)&Buffer.Length = Flags_low;
    goto LABEL_90;
  }
  Status = 0;
  Flags = MasterIrp->Flags;
  if ( Options == 4128 )
    MasterIrp->AssociatedIrp.MasterIrp = 0i64;
  else
    MasterIrp->ThreadListEntry.Flink = 0i64;
  v54 = Flags;
  DbgPrint("[AsIO3]: XXXXXXXX alloc mem size is 0x%lx bytes !", Flags);
  result = (__int64)MmAllocateContiguousMemory(v54, (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
  v56 = (struct _IRP *)result;
  if ( result )
  {
    v57 = 4128i64;
    if ( Options == 4128 )
    {
      DbgPrint("[AsIO3]: XXXXXXXX address is 0x%lx !", *(&MasterIrp->Flags + 1));
      *(&MasterIrp->Flags + 1) = MmGetPhysicalAddress(v56).LowPart;
      MasterIrp->AssociatedIrp.MasterIrp = v56;
    }
    else
    {
      DbgPrint("[AsIO3]: XXXXXXXX address is 0x%lx !", MasterIrp->AssociatedIrp.MasterIrp);
      MasterIrp->AssociatedIrp.MasterIrp = (struct _IRP *)MmGetPhysicalAddress(v56).LowPart;
      MasterIrp->ThreadListEntry.Flink = (struct _LIST_ENTRY *)v56;
      v57 = 4136i64;
    }
    Irp->IoStatus.Information = v57;
    goto LABEL_193;
  }
  return result;
}
/* Orphan comments:
in word
*/
~~~

### IOCTL  0xA040A480

This IOCTL code triggers arbitrary physical memory map operation in function sub_140003268. 

~~~c
__int64 __fastcall sub_140003268(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  PHYSICAL_ADDRESS *v4; // rdi
  HANDLE v5; // rcx
  void *v6; // rax
  DWORD *v7; // r15
  unsigned int v8; // edx
  DWORD *v9; // r12
  NTSTATUS v11; // ebx
  LARGE_INTEGER v12; // rbx
  DWORD v13; // edi
  union _LARGE_INTEGER SectionOffset; // [rsp+58h] [rbp-59h] BYREF
  LARGE_INTEGER TranslatedAddress; // [rsp+60h] [rbp-51h] BYREF
  void *SectionHandle; // [rsp+68h] [rbp-49h] BYREF
  HANDLE Handle; // [rsp+70h] [rbp-41h] BYREF
  ULONG v19; // [rsp+78h] [rbp-39h] BYREF
  LARGE_INTEGER BusAddress; // [rsp+80h] [rbp-31h] BYREF
  PVOID BaseAddress; // [rsp+88h] [rbp-29h] BYREF
  ULONG_PTR ViewSize; // [rsp+90h] [rbp-21h] BYREF
  PVOID v23; // [rsp+98h] [rbp-19h] BYREF
  PVOID Object; // [rsp+A0h] [rbp-11h] BYREF
  PVOID v25; // [rsp+A8h] [rbp-9h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+B0h] [rbp-1h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+E0h] [rbp+2Fh] BYREF
  ULONG AddressSpace; // [rsp+130h] [rbp+7Fh] BYREF

  v4 = *(PHYSICAL_ADDRESS **)(a2 + 24);
  v5 = 0i64;
  v25 = 0i64;
  v6 = 0i64;
  Object = 0i64;
  v7 = 0i64;
  v8 = *(_DWORD *)(a3 + 16);
  v9 = 0i64;
  Handle = 0i64;
  SectionHandle = 0i64;
  if ( a4 )
  {
    v9 = (DWORD *)v4;
    if ( v8 < 0x18 || *(_DWORD *)(a3 + 8) < 4u )
    {
      v11 = -1073741670;
      goto LABEL_33;
    }
  }
  else
  {
    v7 = (DWORD *)v4;
    if ( v8 < 0x18 || *(_DWORD *)(a3 + 8) < 8u )
    {
      v11 = -1073741670;
LABEL_37:
      if ( v5 )
        goto LABEL_38;
      return (unsigned int)v11;
    }
  }
  AddressSpace = v4[2].LowPart;
  v19 = AddressSpace;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( a4 )
  {
    v11 = ZwOpenSection(&SectionHandle, 0xF001Fu, &ObjectAttributes);
    if ( v11 < 0 )
      goto LABEL_32;
    v11 = ObReferenceObjectByHandle(SectionHandle, 0xF001Fu, 0i64, 0, &Object, 0i64);
    if ( v11 < 0 )
      goto LABEL_32;
  }
  else
  {
    v11 = ZwOpenSection(&Handle, 0xF001Fu, &ObjectAttributes);
    if ( v11 < 0 )
      goto LABEL_35;
    v11 = ObReferenceObjectByHandle(Handle, 0xF001Fu, 0i64, 0, &v25, 0i64);
    if ( v11 < 0 )
      goto LABEL_35;
  }
  BusAddress.QuadPart = v4[1].QuadPart + v4[2].HighPart + (unsigned int)(unsigned __int16)v4[1].LowPart;
  if ( HalTranslateBusAddress((INTERFACE_TYPE)v4->LowPart, v4->HighPart, v4[1], &AddressSpace, &TranslatedAddress)
    && HalTranslateBusAddress((INTERFACE_TYPE)v4->LowPart, v4->HighPart, BusAddress, &v19, &BusAddress) )
  {
    v12 = TranslatedAddress;
  }
  else
  {
    v12 = v4[1];
    TranslatedAddress = v12;
  }
  v13 = BusAddress.LowPart - v12.LowPart;
  ViewSize = BusAddress.QuadPart - v12.QuadPart;
  if ( BusAddress.LowPart == v12.LowPart )
  {
    v11 = -1073741823;
    goto LABEL_31;
  }
  if ( (unsigned int)((__int64 (__fastcall *)(_QWORD, _QWORD))sub_1400013E4)((LARGE_INTEGER)v12.QuadPart, v13) )
    return 3221225506i64;
  if ( AddressSpace )
  {
    if ( a4 )
      *v9 = v12.LowPart;
    else
      *v7 = v12.LowPart;
    goto LABEL_30;
  }
  SectionOffset = v12;
  if ( !a4 )
  {
    v23 = 0i64;
    v11 = ZwMapViewOfSection(
            Handle,
            (HANDLE)0xFFFFFFFFFFFFFFFFi64,
            &v23,
            0i64,
            v13,
            &SectionOffset,
            &ViewSize,
            ViewShare,
            0,
            4u);
    if ( v11 >= 0 )
    {
      *v7 = TranslatedAddress.LowPart + (_DWORD)v23 - SectionOffset.LowPart;
      goto LABEL_30;
    }
LABEL_35:
    v5 = Handle;
    goto LABEL_37;
  }
  BaseAddress = 0i64;
  v11 = ZwMapViewOfSection(
          SectionHandle,
          (HANDLE)0xFFFFFFFFFFFFFFFFi64,
          &BaseAddress,
          0i64,
          v13,
          &SectionOffset,
          &ViewSize,
          ViewShare,
          0,
          4u);
  if ( v11 >= 0 )
  {
    LODWORD(BaseAddress) = TranslatedAddress.LowPart - SectionOffset.LowPart + (_DWORD)BaseAddress;
    *v9 = (unsigned int)BaseAddress;
LABEL_30:
    v11 = 0;
LABEL_31:
    if ( a4 )
      goto LABEL_32;
    goto LABEL_35;
  }
LABEL_32:
  v6 = SectionHandle;
LABEL_33:
  if ( v6 )
  {
    v5 = v6;
LABEL_38:
    ZwClose(v5);
  }
  return (unsigned int)v11;
}
~~~



### IOCTL  0xA0406408

This IOCTL code triggers port read operation in function sub_140002654 . 

~~~c
__int64 __fastcall sub_140002654(__int64 a1, _DWORD *a2)
{
  int v2; // edi
  unsigned __int32 *v4; // rsi
  ULONG v5; // ebp
  DWORD LowPart; // ebx
  unsigned __int32 v8; // eax
  unsigned __int16 v9; // ax
  unsigned __int8 v10; // al
  ULONG AddressSpace; // [rsp+60h] [rbp+8h] BYREF
  PHYSICAL_ADDRESS BusAddress; // [rsp+68h] [rbp+10h]
  LARGE_INTEGER TranslatedAddress; // [rsp+78h] [rbp+20h] BYREF

  v2 = a2[6];
  v4 = *(unsigned __int32 **)(a1 + 24);
  switch ( v2 )
  {
    case 0xA0406400:
      v5 = 1;
      break;
    case 0xA0406404:
      v5 = 2;
      break;
    case 0xA0406408:
      v5 = 4;
      break;
    default:
      v5 = AddressSpace;
      break;
  }
  if ( a2[4] == 4 && a2[2] >= v5 )
  {
    BusAddress.QuadPart = *v4;
    AddressSpace = 1;
    HalTranslateBusAddress(Isa, 0, BusAddress, &AddressSpace, &TranslatedAddress);
    LowPart = TranslatedAddress.LowPart;
    if ( (unsigned int)sub_14000130C(LOWORD(TranslatedAddress.LowPart)) )
      return 3221225506i64;
    if ( AddressSpace == 1 )
    {
      if ( v2 != 0xA0406400 )
      {
        if ( v2 != 0xA0406404 )
        {
          if ( v2 == 0xA0406408 )
          {
            v8 = __indword(LowPart);
LABEL_23:
            *v4 = v8;
            goto LABEL_28;
          }
          goto LABEL_28;
        }
        v9 = __inword(LowPart);
        goto LABEL_25;
      }
      v10 = __inbyte(LowPart);
    }
    else
    {
      if ( v2 != -1606392832 )
      {
        if ( v2 != -1606392828 )
        {
          if ( v2 == -1606392824 )
          {
            v8 = *(_DWORD *)LowPart;
            goto LABEL_23;
          }
LABEL_28:
          *(_QWORD *)(a1 + 56) = v5;
          return 0i64;
        }
        v9 = *(_WORD *)LowPart;
LABEL_25:
        *(_WORD *)v4 = v9;
        goto LABEL_28;
      }
      v10 = *(_BYTE *)LowPart;
    }
    *(_BYTE *)v4 = v10;
    goto LABEL_28;
  }
  return 0xC000000Di64;
}
~~~







### IOCTL 0xA0402014

This code triggers port out operation. The operation is eventually completed in function sub_140001000.

```c
__int64 __fastcall sub_140001000(unsigned __int16 a1, __int16 a2, unsigned __int8 a3)
{
  if ( a3 > 1u )
  {
    if ( a3 > 2u )
      __outdword(a1, a2);
    else
      __outword(a1, a2);
  }
  else
  {
    __outbyte(a1, a2);
  }
  return 1i64;
}
```



### IOCTL 0xA0400F88

This code triggers read operation on MSR. 

```c
case 0xA0400F88:
      v59 = *(_DWORD *)&MasterIrp->Type;
      Status = (unsigned int)((__int64 (__fastcall *)(_QWORD, struct _IO_STACK_LOCATION *, __int64, __int64))sub_14000138C)(
                               *(unsigned int *)&MasterIrp->Type,
                               CurrentStackLocation,
                               Length,
                               v5) != 0
             ? 0xC0000022
             : 0;
      MasterIrp->MdlAddress = (PMDL)__readmsr(v59);// rdmsr
      Irp->IoStatus.Information = 16i64;
```



### IOCTL  0xA0400F8C

This code triggers write operation on MSR.

```c
   case 0xA0400F8C:
      v58 = *(_DWORD *)&MasterIrp->Type;
      Status = (unsigned int)((__int64 (__fastcall *)(_QWORD, struct _IO_STACK_LOCATION *, __int64, __int64))sub_14000138C)(
                               *(unsigned int *)&MasterIrp->Type,
                               CurrentStackLocation,
                               Length,
                               v5) != 0
             ? 0xC0000022
             : 0;
      __writemsr(v58, (unsigned __int64)MasterIrp->MdlAddress);// wrmsr
      goto LABEL_193;
```



