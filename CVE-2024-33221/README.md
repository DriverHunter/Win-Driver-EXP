# Vulnerable Driver AsusBSItf.sys in ASUS BIOS Flash Driver v3.2.12.0

---

AsusBSItf.sys in ASUS BIOS Flash Driver exposes functionality that allows low-privileged users to map physical memory between 0xf0000-0x100000 or higher than 0xffff0000, write arbitary i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.



## version

3.03.36

## Vulnerability causes

AsusBSItf.sys provides the functionality of mapping physical memory and read/write I/O ports , but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_140001070(__int64 a1, IRP *a2)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rax
  NTSTATUS v4; // ebx
  DWORD LowPart; // ecx
  unsigned __int64 inputbuffer_len; // rdx
  unsigned __int64 outputbuffer_len; // r9
  UCHAR MajorFunction; // r8
  DWORD v9; // ecx
  DWORD v10; // ecx
  DWORD v11; // ecx
  DWORD v12; // ecx
  DWORD v13; // ecx
  struct _IRP *v14; // rbx
  PDEVICE_OBJECT v15; // rcx
  __int64 v16; // rdx
  _DWORD *inputbuffer; // r15
  unsigned int inputbuffer_0; // ebx
  SIZE_T inputbuffer_3; // r12
  unsigned int inputbuffer_3_1; // edx
  unsigned int inputbuffer_2; // eax
  int inputbuffer_1_1; // r9d
  unsigned int v24; // r8d
  unsigned int v25; // r10d
  int v26; // edx
  _QWORD *mapped_addr; // r13
  PHYSICAL_ADDRESS *allocate_mem; // rax
  LONGLONG *v29; // r14
  PHYSICAL_ADDRESS another_physical_addr; // rcx
  PVOID another_mapped_addr; // rax
  struct _MDL *mdl_for_another_mapped_addr; // rcx
  PVOID v33; // rax
  void *another_mapped_addr_1; // rcx
  PHYSICAL_ADDRESS v35; // rax
  LONGLONG **v36; // rax
  PDEVICE_OBJECT v37; // rcx
  __int64 v38; // rdx
  struct _IRP *v39; // rbx
  struct _IRP *v40; // r14
  PVOID *v41; // rdi
  _QWORD *v42; // rax
  PVOID *v43; // rcx
  struct _MDL *v44; // rdx
  PVOID v45; // rcx
  PVOID v46; // rcx
  PDEVICE_OBJECT v47; // rcx
  __int64 v48; // rdx
  PVOID PoolWithTag; // rdi
  ULONG v50; // r15d
  PVOID ContiguousMemory; // rax
  struct _MDL *v52; // rcx
  PVOID v53; // rax
  void *v54; // rcx
  _QWORD *v55; // rax
  void *v56; // rcx
  DWORD *pinputbuffer; // rbx
  __int64 inputbuffer_1_2; // r8
  unsigned int inputbuffer_0_1; // r14d
  unsigned int v60; // r12d
  unsigned int v61_ffff0000; // r15d
  char *v62; // rax
  char *v63; // r14
  PHYSICAL_ADDRESS PhysicalAddress; // [rsp+40h] [rbp-48h]
  int inputbuffer_1; // [rsp+48h] [rbp-40h] BYREF
  unsigned int v66[3]; // [rsp+4Ch] [rbp-3Ch]

  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  v4 = 0xC0000002;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  inputbuffer_len = CurrentStackLocation->Parameters.Create.Options;
  outputbuffer_len = CurrentStackLocation->Parameters.Read.Length;
  a2->IoStatus.Information = 0i64;
  MajorFunction = CurrentStackLocation->MajorFunction;
  if ( !CurrentStackLocation->MajorFunction || MajorFunction == 2 )
    goto LABEL_25;
  if ( MajorFunction != 14 )
    goto LABEL_26;
  v9 = LowPart - 0x222804;
  if ( !v9 )                                    // 0x222804
  {
    pinputbuffer = (DWORD *)a2->AssociatedIrp.MasterIrp;
    inputbuffer_1_2 = pinputbuffer[1];
    if ( inputbuffer_len < inputbuffer_1_2 + 8 || outputbuffer_len < inputbuffer_1_2 + 8 )// inputbuffer_len>=inputbuffer[1]+8
                                                // outputbuffer_len>=inputbuffer[1]+8
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 10i64;
      goto LABEL_14;
    }
    inputbuffer_0_1 = *pinputbuffer;
    v60 = *pinputbuffer + inputbuffer_1_2 - 1;
    v61_ffff0000 = -(int)NumberOfBytes;         // ffff0000
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject )
    {
      if ( (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140001F44(
          DeviceObject->AttachedDevice,
          11i64,
          &unk_140003280,
          inputbuffer_0_1,
          inputbuffer_0_1 + inputbuffer_1_2 - 1);
      if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140001F44(DeviceObject->AttachedDevice, 12i64, &unk_140003280, v61_ffff0000, -1);
    }
    if ( (inputbuffer_0_1 < 0xF0000 || v60 > 0xFFFFF) && inputbuffer_0_1 < v61_ffff0000 )// inputbuffer[0]>=0xf0000 && inputbuffer[0]+inputbuffer[1]-1<0xfffff
                                                // 
                                                // or
                                                // 
                                                // inputbuffer[0]>=ffff0000
    {
      if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140001F44(DeviceObject->AttachedDevice, 14i64, &unk_140003280, inputbuffer_0_1, v60);
      goto LABEL_17;
    }
    v62 = (char *)MmMapIoSpace((PHYSICAL_ADDRESS)*pinputbuffer, pinputbuffer[1], MmNonCached);// mapping range is 0xf0000-0x100000
                                                // or ffff0000
    v63 = v62;
    if ( v62 )
    {
      sub_140002300(pinputbuffer + 2, v62, pinputbuffer[1]);
      MmUnmapIoSpace(v63, pinputbuffer[1]);
      a2->IoStatus.Information = pinputbuffer[1] + 8i64;
      goto LABEL_25;
    }
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
      sub_140001EE0(DeviceObject->AttachedDevice, 13i64, &unk_140003280);
    v4 = -1073741823;
    goto LABEL_26;
  }
  v10 = v9 - 4;
  if ( !v10 )                                   // 0x222808
  {
    v40 = a2->AssociatedIrp.MasterIrp;
    if ( (unsigned int)inputbuffer_len < 4 || (unsigned int)outputbuffer_len < 0x10 )
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 15i64;
      goto LABEL_14;
    }
    v4 = -1073741670;
    PoolWithTag = ExAllocatePoolWithTag((POOL_TYPE)1024, 0x30ui64, 0x704D4Du);
    if ( PoolWithTag )
    {
      v50 = *(_DWORD *)a2->AssociatedIrp.MasterIrp;
      *(_OWORD *)PoolWithTag = 0i64;
      *((_OWORD *)PoolWithTag + 1) = 0i64;
      *((_OWORD *)PoolWithTag + 2) = 0i64;
      ContiguousMemory = MmAllocateContiguousMemory(v50, (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
      *((_QWORD *)PoolWithTag + 2) = ContiguousMemory;
      if ( ContiguousMemory )
        *((_QWORD *)PoolWithTag + 3) = IoAllocateMdl(ContiguousMemory, v50, 0, 0, 0i64);
      v52 = (struct _MDL *)*((_QWORD *)PoolWithTag + 3);
      if ( v52 )
      {
        MmBuildMdlForNonPagedPool(v52);
        v53 = MmMapLockedPages(*((PMDL *)PoolWithTag + 3), 1);
        v54 = (void *)*((_QWORD *)PoolWithTag + 2);
        *((_QWORD *)PoolWithTag + 5) = v53;
        *((PHYSICAL_ADDRESS *)PoolWithTag + 4) = MmGetPhysicalAddress(v54);
        *(_QWORD *)&v40->Type = *((_QWORD *)PoolWithTag + 5);
        v40->MdlAddress = (PMDL)*((_QWORD *)PoolWithTag + 4);
        a2->IoStatus.Information = 16i64;
        v55 = (_QWORD *)qword_1400042B8;
        if ( *(PVOID **)qword_1400042B8 != &P )
          goto LABEL_92;
        *(_QWORD *)PoolWithTag = &P;
        *((_QWORD *)PoolWithTag + 1) = v55;
        *v55 = PoolWithTag;
        qword_1400042B8 = (__int64)PoolWithTag;
        v47 = DeviceObject;
        if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
          goto LABEL_25;
        v48 = 16i64;
        goto LABEL_84;
      }
      v56 = (void *)*((_QWORD *)PoolWithTag + 2);
      if ( v56 )
        MmFreeContiguousMemory(v56);
      ExFreePoolWithTag(PoolWithTag, 0x704D4Du);
    }
    v37 = DeviceObject;
    if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
      goto LABEL_26;
    v38 = 17i64;
LABEL_54:
    sub_140001EE0(v37->AttachedDevice, v38, &unk_140003280);
    goto LABEL_26;
  }
  v11 = v10 - 4;                                // 0x22280c
  if ( !v11 )
  {
    v40 = a2->AssociatedIrp.MasterIrp;
    if ( (unsigned int)inputbuffer_len < 0x10 )
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 18i64;
      goto LABEL_14;
    }
    v41 = (PVOID *)P;
    v4 = -1073741823;
    if ( P == &P )
    {
LABEL_71:
      if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140002040(DeviceObject->AttachedDevice, 20i64, &unk_140003280, v40->MdlAddress, *(_QWORD *)&v40->Type);
      goto LABEL_26;
    }
    while ( *(PVOID *)&v40->Type != v41[5] || v40->MdlAddress != v41[4] )
    {
      v41 = (PVOID *)*v41;
      if ( v41 == &P )
        goto LABEL_71;
    }
    v42 = *v41;
    if ( *((PVOID **)*v41 + 1) != v41 )
      goto LABEL_92;
    v43 = (PVOID *)v41[1];
    if ( *v43 != v41 )
      goto LABEL_92;
    *v43 = v42;
    v42[1] = v43;
    v44 = (struct _MDL *)v41[3];
    if ( v44 )
    {
      v45 = v41[5];
      if ( v45 )
      {
        MmUnmapLockedPages(v45, v44);
        IoFreeMdl((PMDL)v41[3]);                // free
      }
    }
    v46 = v41[2];
    if ( v46 )
      MmFreeContiguousMemory(v46);
    ExFreePoolWithTag(v41, 0x704D4Du);
    v47 = DeviceObject;
    if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
      goto LABEL_25;
    v48 = 19i64;
LABEL_84:
    sub_140002040(v47->AttachedDevice, v48, &unk_140003280, v40->MdlAddress, *(_QWORD *)&v40->Type);
    goto LABEL_25;
  }
  v12 = v11 - 4;                                // 0x222810
  if ( !v12 )
  {
    v39 = a2->AssociatedIrp.MasterIrp;
    if ( (unsigned int)inputbuffer_len < 8 )
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 21i64;
      goto LABEL_14;
    }
    if ( !word_14000400C )
      goto LABEL_17;
    ((void (__fastcall *)(_QWORD, _QWORD, _QWORD, unsigned __int64))out_func)(
      word_14000400C,
      *(unsigned int *)&v39->Type,
      *(unsigned int *)(&v39->Size + 1),
      outputbuffer_len);
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
      sub_140001F44(
        DeviceObject->AttachedDevice,
        22i64,
        &unk_140003280,
        *(unsigned int *)&v39->Type,
        *(_DWORD *)(&v39->Size + 1));
    goto LABEL_25;
  }
  v13 = v12 - 4;                                // 0x222814
  if ( !v13 )
  {
    inputbuffer = &a2->AssociatedIrp.MasterIrp->Type;
    if ( (unsigned int)inputbuffer_len < 0x20 )
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 23i64;
      goto LABEL_14;
    }
    if ( !word_14000400C )
      goto LABEL_17;
    inputbuffer_0 = *inputbuffer;
    inputbuffer_3 = (unsigned int)inputbuffer[3];
    inputbuffer_3_1 = inputbuffer[3];
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
    {
      sub_140001FE0(DeviceObject->AttachedDevice, 24i64, &unk_140003280, inputbuffer_0);
      inputbuffer_3_1 = inputbuffer[3];
    }
    inputbuffer_1 = inputbuffer[1];
    inputbuffer_2 = inputbuffer[2];
    v66[1] = inputbuffer_3_1;
    v66[0] = inputbuffer_2;
    sub_14000101E(word_14000400C, inputbuffer_0, &inputbuffer_1);// 0xb2 port
    inputbuffer_1_1 = inputbuffer_1;
    v24 = v66[0];
    v25 = v66[1];
    inputbuffer[1] = inputbuffer_1;
    inputbuffer[2] = v24;                       // (DWORD*)inputbuffer[2]
    inputbuffer[3] = v25;                       // (DWORD*)inputbuffer[1]
    v26 = inputbuffer_1_1;
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
    {
      sub_140001F8C(DeviceObject->AttachedDevice, 25i64, &unk_140003280);
      v26 = inputbuffer[1];
    }
    *((_QWORD *)inputbuffer + 2) = 0i64;
    v4 = 0;
    *((_QWORD *)inputbuffer + 3) = 0i64;
    if ( v26 )
    {
LABEL_49:
      a2->IoStatus.Information = 32i64;
      goto LABEL_26;
    }
    PhysicalAddress.HighPart = inputbuffer[2];
    PhysicalAddress.LowPart = inputbuffer[3];
    mapped_addr = MmMapIoSpace(PhysicalAddress, 0x18ui64, MmNonCached);// mapping memory specified  by inputbuffer[2],inputbuffer[3]
    if ( !mapped_addr )
    {
      v4 = 0xC000009A;
LABEL_51:
      v37 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_26;
      v38 = 26i64;
      goto LABEL_54;
    }
    allocate_mem = (PHYSICAL_ADDRESS *)ExAllocatePoolWithTag((POOL_TYPE)1024, 0x30ui64, 0x704D4Du);
    v29 = (LONGLONG *)allocate_mem;
    if ( !allocate_mem )
    {
      v4 = 0xC000009A;
LABEL_48:
      MmUnmapIoSpace(mapped_addr, 0x18ui64);
      if ( v4 >= 0 )
        goto LABEL_49;
      goto LABEL_51;
    }
    another_physical_addr = (PHYSICAL_ADDRESS)mapped_addr[1];// Here, because the address is not checked for readability before mapping, it can lead to a blue screen if it is not readable.
    allocate_mem[4] = another_physical_addr;
    another_mapped_addr = MmMapIoSpace(another_physical_addr, inputbuffer_3, MmNonCached);// mapping memory specified by mapped_addr[1] it's weird???
                                                // another_physical_addr = mapped_addr[1] 
    v29[2] = (LONGLONG)another_mapped_addr;
    if ( another_mapped_addr )
      v29[3] = (LONGLONG)IoAllocateMdl(another_mapped_addr, inputbuffer_3, 0, 0, 0i64);
    mdl_for_another_mapped_addr = (struct _MDL *)v29[3];
    if ( !mdl_for_another_mapped_addr )
    {
      v4 = -1073741670;
      ExFreePoolWithTag(v29, 0x704D4Du);
      goto LABEL_48;
    }
    MmBuildMdlForNonPagedPool(mdl_for_another_mapped_addr);
    v33 = MmMapLockedPages((PMDL)v29[3], 1);    
    another_mapped_addr_1 = (void *)v29[2];
    v29[5] = (LONGLONG)v33;
    v35 = MmGetPhysicalAddress(another_mapped_addr_1);
    v29[2] = 0i64;
    v29[4] = v35.QuadPart;
    v36 = (LONGLONG **)qword_1400042B8;
    if ( *(PVOID **)qword_1400042B8 == &P )
    {
      *v29 = (LONGLONG)&P;
      v29[1] = (LONGLONG)v36;
      *v36 = v29;
      qword_1400042B8 = (__int64)v29;
      *((_QWORD *)inputbuffer + 3) = v29[4];
      *((_QWORD *)inputbuffer + 2) = v29[5];
      goto LABEL_48;
    }
LABEL_92:
    __fastfail(3u);
  }
  if ( v13 == 4 )                               // 0x222818
  {
    v14 = a2->AssociatedIrp.MasterIrp;
    if ( (unsigned int)inputbuffer_len < 8 )
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 27i64;
LABEL_14:
      sub_140001EE0(v15->AttachedDevice, v16, &unk_140003280);
LABEL_15:
      v4 = -1073741811;
      goto LABEL_26;
    }
    if ( !word_14000400C )
    {
LABEL_17:
      v4 = -1073741637;
      goto LABEL_26;
    }
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
      sub_140001F44(
        DeviceObject->AttachedDevice,
        28i64,
        &unk_140003280,
        *(unsigned int *)&v14->Type,
        *(_DWORD *)(&v14->Size + 1));
    sub_14000104B(word_14000400C, *(_DWORD *)&v14->Type, &v14->Size + 1);
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
      sub_140001F08(DeviceObject->AttachedDevice, 29i64, &unk_140003280, *(unsigned int *)(&v14->Size + 1));
    a2->IoStatus.Information = 8i64;
LABEL_25:
    v4 = 0;
  }
LABEL_26:
  a2->IoStatus.Status = v4;
  IofCompleteRequest(a2, 0);
  return (unsigned int)v4;
}
~~~

### IOCTL  0x222804

This IOCTL code triggers physical memory map operation. 

~~~c
  v9 = LowPart - 0x222804;
  if ( !v9 )                                    // 0x222804
  {
    pinputbuffer = (DWORD *)a2->AssociatedIrp.MasterIrp;
    inputbuffer_1_2 = pinputbuffer[1];
    if ( inputbuffer_len < inputbuffer_1_2 + 8 || outputbuffer_len < inputbuffer_1_2 + 8 )// inputbuffer_len>=inputbuffer[1]+8
                                                // outputbuffer_len>=inputbuffer[1]+8
    {
      v15 = DeviceObject;
      if ( DeviceObject == (PDEVICE_OBJECT)&DeviceObject || (HIDWORD(DeviceObject->Timer) & 4) == 0 )
        goto LABEL_15;
      v16 = 10i64;
      goto LABEL_14;
    }
    inputbuffer_0_1 = *pinputbuffer;
    v60 = *pinputbuffer + inputbuffer_1_2 - 1;
    v61_ffff0000 = -(int)NumberOfBytes;         // ffff0000
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject )
    {
      if ( (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140001F44(
          DeviceObject->AttachedDevice,
          11i64,
          &unk_140003280,
          inputbuffer_0_1,
          inputbuffer_0_1 + inputbuffer_1_2 - 1);
      if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140001F44(DeviceObject->AttachedDevice, 12i64, &unk_140003280, v61_ffff0000, -1);
    }
    if ( (inputbuffer_0_1 < 0xF0000 || v60 > 0xFFFFF) && inputbuffer_0_1 < v61_ffff0000 )// inputbuffer[0]>=0xf0000 && inputbuffer[0]+inputbuffer[1]-1<0xfffff
                                                // 
                                                // or
                                                // 
                                                // inputbuffer[0]>=ffff0000
    {
      if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
        sub_140001F44(DeviceObject->AttachedDevice, 14i64, &unk_140003280, inputbuffer_0_1, v60);
      goto LABEL_17;
    }
    v62 = (char *)MmMapIoSpace((PHYSICAL_ADDRESS)*pinputbuffer, pinputbuffer[1], MmNonCached);// mapping range is 0xf0000-0x100000
                                                // or ffff0000
    v63 = v62;
    if ( v62 )
    {
      sub_140002300(pinputbuffer + 2, v62, pinputbuffer[1]);
      MmUnmapIoSpace(v63, pinputbuffer[1]);
      a2->IoStatus.Information = pinputbuffer[1] + 8i64;
      goto LABEL_25;
    }
    if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject && (HIDWORD(DeviceObject->Timer) & 4) != 0 )
      sub_140001EE0(DeviceObject->AttachedDevice, 13i64, &unk_140003280);
    v4 = -1073741823;
    goto LABEL_26;
  }
~~~



### IOCTL  0x222810

This IOCTL code triggers port write operation in function sub_140001000. 

~~~c
__int16 __fastcall sub_140001000(unsigned __int16 a1, __int16 a2)
{
  __int16 result; // ax

  result = a2;
  if ( HIBYTE(a2) )
    __outword(a1, a2);
  else
    __outbyte(a1, a2);
  return result;
}
~~~




