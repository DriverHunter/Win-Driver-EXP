# Vulnerable Driver  Access64.sys in Wistron Corporation TBT Force Power Control v1.0.0.0

---

Access64.sys in Wistron Corporation TBT Force Power Control v1.0.0.0 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

6.0.9549.1

## Vulnerability causes

 Access64.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

```c
__int64 __fastcall ioctler(__int64 a1, __int64 a2)
{
  _DWORD *v2; // rcx
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v11; // ebx
  __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // r8
  unsigned __int16 *v15; // rcx
  unsigned __int16 v16; // dx
  unsigned __int32 v17; // eax
  unsigned __int16 v18; // ax
  unsigned __int8 v19; // al
  __int64 v20; // rax
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // eax
  PVOID *v25; // rbx
  __int64 v26; // rcx
  __int64 v27; // rcx
  unsigned __int32 v28; // eax
  unsigned int *v29; // rbx
  PVOID ContiguousMemory; // rax
  unsigned int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // eax
  unsigned int v34; // eax
  unsigned int v35; // eax
  __int64 v36; // rbx
  unsigned int v37; // eax
  unsigned int v38; // eax
  unsigned int v39; // eax
  unsigned int v40; // eax

  v2 = *(_DWORD **)(a2 + 184);
  v4 = v2[6];
  if ( v4 > 0x2220C4 )
  {
    if ( v4 > 0x222140 )
    {
      v37 = v4 - 2236740;
      if ( v37 )
      {
        v38 = v37 - 60;
        if ( !v38 )
          return (unsigned int)sub_11DB8((PIRP)a2);
        v39 = v38 - 4;
        if ( !v39 )
          return (unsigned int)sub_11ED4((PIRP)a2);
        v40 = v39 - 4;
        if ( !v40 )
          return (unsigned int)sub_11F8C((PIRP)a2);
        if ( v40 == 4 )
          return (unsigned int)sub_12044((PIRP)a2);
        goto LABEL_85;
      }
      if ( v2[4] == 12 )
      {
        __writemsr(**(_DWORD **)(a2 + 24), *(_QWORD *)(*(_QWORD *)(a2 + 24) + 4i64));
        goto LABEL_95;
      }
      goto LABEL_91;
    }
    if ( v4 != 2236736 )
    {
      v31 = v4 - 2236616;
      if ( v31 )
      {
        v32 = v31 - 4;
        if ( !v32 )
          return (unsigned int)sub_11A58((PIRP)a2);// map primitive
        v33 = v32 - 4;
        if ( !v33 )
          return (unsigned int)sub_11B50((PIRP)a2);
        v34 = v33 - 4;
        if ( !v34 )
          return (unsigned int)sub_11C40((PIRP)a2);
        v35 = v34 - 44;
        if ( !v35 )
          return (unsigned int)sub_11CF4((PIRP)a2);
        if ( v35 != 4 )
          goto LABEL_85;
        if ( v2[4] == 11 )
        {
          v36 = *(_QWORD *)(a2 + 24);
          if ( HalSetBusDataByOffset(
                 PCIConfiguration,
                 *(unsigned __int8 *)(v36 + 2),
                 (*(_DWORD *)v36 & 0x700 | (*(_DWORD *)v36 >> 8) & 0xF8u) >> 3,
                 (PVOID)(v36 + 7),
                 *(unsigned __int16 *)(v36 + 4),
                 *(unsigned __int8 *)(v36 + 6)) != *(unsigned __int8 *)(v36 + 6) )
          {
            *(_QWORD *)(a2 + 56) = 0i64;
            *(_DWORD *)(a2 + 48) = -1073741491;
            IofCompleteRequest((PIRP)a2, 0);
          }
          goto LABEL_95;
        }
      }
      else if ( v2[4] == 16 )
      {
        MmFreeContiguousMemory(*(PVOID *)(*(_QWORD *)(a2 + 24) + 8i64));
        goto LABEL_95;
      }
      goto LABEL_91;
    }
    if ( v2[4] != 4 && v2[2] != 8 )
      goto LABEL_91;
    **(_QWORD **)(a2 + 24) = __readmsr(**(_DWORD **)(a2 + 24));
    goto LABEL_47;
  }
  if ( v4 == 2236612 )
  {
    if ( v2[4] != 12 || v2[2] < 0x10u )
      goto LABEL_91;
    v29 = *(unsigned int **)(a2 + 24);
    ContiguousMemory = MmAllocateContiguousMemory(*v29, *(PHYSICAL_ADDRESS *)(v29 + 1));
    *((_QWORD *)v29 + 1) = ContiguousMemory;
    *(PHYSICAL_ADDRESS *)v29 = MmGetPhysicalAddress(ContiguousMemory);
    *(_QWORD *)(a2 + 56) = 16i64;
    goto LABEL_96;
  }
  if ( v4 > 0x222050 )
  {
    v21 = v4 - 2236500;
    if ( !v21 )
    {
      if ( v2[4] != 6 || v2[2] != 4 )
        goto LABEL_91;
      v27 = *(_QWORD *)(a2 + 24);
      __outdword(0xCF8u, *(_DWORD *)v27 | *(_WORD *)(v27 + 4) & 0xFC);
      v28 = __indword(0xCFCu);
      *(_DWORD *)v27 = v28;
      *(_QWORD *)(a2 + 56) = 4i64;
      goto LABEL_96;
    }
    v22 = v21 - 4;
    if ( !v22 )
    {
      if ( v2[4] == 11 )
      {
        v26 = *(_QWORD *)(a2 + 24);
        if ( *(_BYTE *)(v26 + 6) == 4 )
        {
          __outdword(0xCF8u, *(_DWORD *)v26 | *(_WORD *)(v26 + 4) & 0xFC);
          __outdword(0xCFCu, *(_DWORD *)(v26 + 7));
          goto LABEL_95;
        }
      }
LABEL_91:
      v11 = -1073741811;
      goto LABEL_92;
    }
    v23 = v22 - 4;
    if ( !v23 )
    {
      if ( v2[4] != 4 )
        goto LABEL_14;
      dword_1416C = **(_DWORD **)(a2 + 24);
      goto LABEL_95;
    }
    v24 = v23 - 4;
    if ( !v24 )
      return (unsigned int)sub_118C0((PIRP)a2);
    if ( v24 != 96 )
      goto LABEL_85;
    if ( v2[4] != 8 || v2[2] < 8u )
      goto LABEL_91;
    v25 = *(PVOID **)(a2 + 24);
    *(PHYSICAL_ADDRESS *)v25 = MmGetPhysicalAddress(*v25);
LABEL_47:
    *(_QWORD *)(a2 + 56) = 8i64;
    goto LABEL_96;
  }
  if ( v4 == 2236496 )
    return (unsigned int)sub_117C8((PIRP)a2);
  v5 = v4 - 2236416;
  if ( !v5 )
  {
    if ( v2[2] >= 6u )
    {
      v20 = *(_QWORD *)(a2 + 24);
      *(_BYTE *)v20 = 2;
      *(_BYTE *)(v20 + 1) = 0;
      *(_WORD *)(v20 + 2) = 2013;
      *(_BYTE *)(v20 + 4) = 4;
      *(_BYTE *)(v20 + 5) = 12;
      *(_QWORD *)(a2 + 56) = 6i64;
      goto LABEL_96;
    }
    goto LABEL_34;
  }
  v6 = v5 - 4;
  if ( !v6 )
  {
    if ( v2[2] >= 4u )
    {
      **(_DWORD **)(a2 + 24) = dword_14180;
      *(_QWORD *)(a2 + 56) = 4i64;
      goto LABEL_96;
    }
LABEL_34:
    v11 = -1073741789;
    goto LABEL_15;
  }
  v7 = v6 - 60;
  if ( !v7 )
  {
    v14 = (unsigned int)v2[2];
    if ( v2[4] != 2 )
      goto LABEL_91;
    v15 = *(unsigned __int16 **)(a2 + 24);
    v16 = *v15;
    switch ( (_DWORD)v14 )                      // in primitive
    {
      case 1:
        v19 = __inbyte(v16);
        *(_BYTE *)v15 = v19;
        break;
      case 2:
        v18 = __inword(v16);
        *v15 = v18;
        break;
      case 4:
        v17 = __indword(v16);
        *(_DWORD *)v15 = v17;
        break;
      default:
        goto LABEL_21;
    }
    *(_QWORD *)(a2 + 56) = v14;
LABEL_96:
    *(_DWORD *)(a2 + 48) = 0;
    IofCompleteRequest((PIRP)a2, 0);
    return 0;
  }
  v8 = v7 - 4;
  if ( !v8 )                                    // out primitive
  {
    if ( v2[4] == 7 )
    {
      v13 = *(_QWORD *)(a2 + 24);
      switch ( *(_BYTE *)(v13 + 2) )
      {
        case 1:
          __outbyte(*(_WORD *)v13, *(_BYTE *)(v13 + 3));
          break;
        case 2:
          __outword(*(_WORD *)v13, *(_WORD *)(v13 + 3));
          break;
        case 4:
          __outdword(*(_WORD *)v13, *(_DWORD *)(v13 + 3));
          break;
        default:
LABEL_21:
          v11 = -1073741788;
LABEL_92:
          *(_QWORD *)(a2 + 56) = 0i64;
          goto LABEL_93;
      }
LABEL_95:
      *(_QWORD *)(a2 + 56) = 0i64;
      goto LABEL_96;
    }
    goto LABEL_91;
  }
  v9 = v8 - 4;
  if ( !v9 )
  {
    if ( v2[4] != 6 )
    {
LABEL_14:
      v11 = -1073741811;
LABEL_15:
      *(_QWORD *)(a2 + 56) = 0i64;
LABEL_93:
      *(_DWORD *)(a2 + 48) = v11;
      IofCompleteRequest((PIRP)a2, 0);
      return v11;
    }
    v12 = *(_QWORD *)(a2 + 24);
    dword_14164 = *(_DWORD *)v12;
    word_14168 = *(_WORD *)(v12 + 4);
    goto LABEL_95;
  }
  if ( v9 != 4 )
  {
LABEL_85:
    v11 = -1073741808;
    goto LABEL_92;
  }
  return (unsigned int)sub_116B8((PIRP)a2);
}
```

### IOCTL  0x2220CC

This IOCTL code triggers memory map operation as blow.

~~~c
    if ( v4 != 0x222140 )
    {
      v31 = v4 - 0x2220C8;
      if ( v31 )
      {
        v32 = v31 - 4;
        if ( !v32 )
          return (unsigned int)((__int64 (__fastcall *)(PIRP))sub_11A58)((PIRP)a2);// map primitive
~~~

### IOCTL  0x222040

This IOCTL code triggers port in operation as blow.

~~~c
 if ( !v7 )
  {
    v14 = (unsigned int)v2[2];
    if ( v2[4] != 2 )
      goto LABEL_91;
    v15 = *(unsigned __int16 **)(a2 + 24);
    v16 = *v15;
    switch ( (_DWORD)v14 )                      // in primitive
    {
      case 1:
        v19 = __inbyte(v16);
        *(_BYTE *)v15 = v19;
        break;
      case 2:
        v18 = __inword(v16);
        *v15 = v18;
        break;
      case 4:
        v17 = __indword(v16);
        *(_DWORD *)v15 = v17;
        break;
      default:
        goto LABEL_21;
    }
~~~

### IOCTL  0x222044

This IOCTL code triggers port out operation as blow.

~~~c
  v8 = v7 - 4;
  if ( !v8 )                                    // out primitive
  {
    if ( v2[4] == 7 )
    {
      v13 = *(_QWORD *)(a2 + 24);
      switch ( *(_BYTE *)(v13 + 2) )
      {
        case 1:
          __outbyte(*(_WORD *)v13, *(_BYTE *)(v13 + 3));
          break;
        case 2:
          __outword(*(_WORD *)v13, *(_WORD *)(v13 + 3));
          break;
        case 4:
          __outdword(*(_WORD *)v13, *(_DWORD *)(v13 + 3));
          break;
        default:
LABEL_21:
          v11 = -1073741788;
LABEL_92:
          *(_QWORD *)(a2 + 56) = 0i64;
          goto LABEL_93;
      }
LABEL_95:
      *(_QWORD *)(a2 + 56) = 0i64;
      goto LABEL_96;
    }
    goto LABEL_91;
  }
~~~





