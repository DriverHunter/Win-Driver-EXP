# Vulnerable Driver  rtkio64.sys in Realtek Semiconductor Corp Realtek lO Driver v1.008.0823.2017

---

rtkio64.sys in Realtek Semiconductor Corp Realtek lO Driver v1.008.0823.2017 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write i/o port via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

1.008.0823.2017

## Vulnerability causes

rtkio64.sys provides the functionality of mapping physical memory, read/write I/O ports, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall sub_134BC(__int64 a1, __int64 a2)
{
  unsigned int v3; // r12d
  unsigned __int16 *v4; // r13
  unsigned int v5; // ebx
  __int64 v6; // r9
  unsigned __int16 v7; // si
  unsigned __int8 v8; // di
  unsigned __int16 v9; // bx
  KAFFINITY ActiveProcessors; // rax
  __int64 v11; // rdx
  __int64 v12; // rbx
  unsigned __int8 v13; // al
  unsigned __int16 v14; // ax
  unsigned __int32 v15; // eax
  unsigned int *v16; // rbx
  _QWORD *v17; // rsi
  struct _MDL *v18; // rsi
  PVOID v19; // rax
  struct _MDL *Mdl; // rax
  unsigned int *PoolWithTag; // rax
  __int64 LowPart_low; // rcx
  __int64 v23; // r9
  unsigned __int16 v24; // ax
  int v25; // eax
  __int64 v26; // rcx
  __int64 v27; // r8
  int v28; // eax
  unsigned int v29; // ebx
  unsigned int v30; // eax
  __int64 v31; // rbx
  unsigned __int8 v32; // al
  char v33; // al
  int v34; // ecx
  int v35; // r8d
  int v36; // edx
  int v37; // ecx
  __int64 v38; // rdx
  int v39; // eax
  unsigned __int16 v40; // r11
  unsigned __int32 v41; // eax
  unsigned __int8 v42; // al
  unsigned __int8 v43; // bl
  unsigned __int16 v44; // dx
  unsigned __int16 v45; // dx
  unsigned __int16 v46; // r11
  unsigned __int32 v47; // eax
  unsigned __int8 v48; // al
  unsigned __int8 v49; // bl
  unsigned __int16 v50; // dx
  unsigned __int16 v51; // ax
  PIRP Irp; // [rsp+20h] [rbp-B8h]
  PIRP Irpa; // [rsp+20h] [rbp-B8h]
  PIRP Irpb; // [rsp+20h] [rbp-B8h]
  PIRP Irpc; // [rsp+20h] [rbp-B8h]
  PIRP Irpd; // [rsp+20h] [rbp-B8h]
  PIRP Irpe; // [rsp+20h] [rbp-B8h]
  PIRP Irpf; // [rsp+20h] [rbp-B8h]
  unsigned __int16 v60; // [rsp+70h] [rbp-68h]
  unsigned __int16 v61; // [rsp+72h] [rbp-66h]
  PVOID v62; // [rsp+78h] [rbp-60h]
  __int16 v63; // [rsp+78h] [rbp-60h]
  PVOID BaseAddress; // [rsp+F0h] [rbp+18h] BYREF
  PHYSICAL_ADDRESS PhysicalAddress; // [rsp+F8h] [rbp+20h] BYREF

  v3 = 0;
  if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject
    && (BYTE4(DeviceObject->Timer) & 1) != 0
    && BYTE1(DeviceObject->Timer) >= 4u )
  {
    sub_11314(DeviceObject->AttachedDevice, 42i64, &unk_16150);
  }
  *(_DWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0i64;
  PhysicalAddress = *(PHYSICAL_ADDRESS *)(a2 + 184);
  v4 = *(unsigned __int16 **)(a2 + 24);
  v5 = *(_DWORD *)(PhysicalAddress.QuadPart + 16);
  LODWORD(BaseAddress) = *(_DWORD *)(PhysicalAddress.QuadPart + 8);
  sub_110AC(5i64, "inBufLength=%x outBufLength=%x", v5, (unsigned int)BaseAddress);
  if ( !v5 )
  {
    v3 = -1073741811;
    goto LABEL_120;
  }
  sub_110AC(5i64, "IoControlCode = %x", *(unsigned int *)(PhysicalAddress.QuadPart + 24));
  sub_111C8(*(unsigned int *)(PhysicalAddress.QuadPart + 24));
  v6 = *(unsigned int *)(PhysicalAddress.QuadPart + 24);
  if ( (unsigned int)v6 > 0x8000201C )
  {
    switch ( (_DWORD)v6 )
    {
      case 0x80002024:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETEEPROM\n");
        sub_110AC(5i64, "IoBase =%x Reg = %x\n", *v4, v4[1]);
        v46 = 6;
        if ( v5 == 6 && (unsigned int)BaseAddress >= 2 )
        {
          *(_QWORD *)(a2 + 56) = 2i64;
          v47 = __indword(*v4 + 68);
          if ( (v47 & 0x40) != 0 )
            v46 = 7;
          v48 = __inbyte(*v4 + 80);
          v49 = v48;
          v50 = *v4 + 80;
          __outbyte(v50, 0x80u);
          __outbyte(v50, 0x84u);
          __outbyte(v50, 0x80u);
          v51 = sub_12040((unsigned int)*v4 + 80, v4[1], v46);
          *v4 = v51;
          __outbyte(v51 + 80, 0x80u);
          __outbyte(v51 + 80, 0x84u);
          __outbyte(v51 + 80, 0x80u);
          __outbyte(*v4 + 80, v49);
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002028:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETEEEPROM\n");
        sub_110AC(5i64, "IoBase =%x Reg = %x Value = %x\n", *v4, v4[1], v4[2]);
        v40 = 6;
        if ( v5 == 6 )
        {
          *(_QWORD *)(a2 + 56) = 2i64;
          v41 = __indword(*v4 + 68);
          if ( (v41 & 0x40) != 0 )
            v40 = 7;
          v42 = __inbyte(*v4 + 80);
          v43 = v42;
          v44 = *v4 + 80;
          __outbyte(v44, 0x80u);
          __outbyte(v44, 0x84u);
          __outbyte(v44, 0x80u);
          sub_12320((unsigned int)*v4 + 80, v4[1], v4[2], v40);
          v45 = *v4 + 80;
          __outbyte(v45, 0x80u);
          __outbyte(v45, 0x84u);
          __outbyte(v45, 0x80u);
          __outbyte(v45, v43);
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x8000202C:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETCHANNEL\n");
        sub_110AC(
          5i64,
          "BUS =%x DEV = %x FN = %x PcieBase = %p\n",
          *(unsigned __int8 *)v4,
          *((unsigned __int8 *)v4 + 1),
          *((unsigned __int8 *)v4 + 2),
          *((const void **)v4 + 3));
        LODWORD(Irpe) = *((_DWORD *)v4 + 2);
        sub_110AC(
          5i64,
          "MutexType =%x AddrRegOffset = %x AddrRegValue = %x\n",
          *((unsigned __int8 *)v4 + 3),
          *((unsigned __int8 *)v4 + 4),
          Irpe);
        LODWORD(Irpf) = v4[10];
        sub_110AC(
          5i64,
          "DataRegOffset =%x DataRegValue = %x WaitTime = %x\n",
          *((unsigned __int8 *)v4 + 12),
          *((unsigned int *)v4 + 4),
          Irpf);
        if ( v5 == 40 && (unsigned int)BaseAddress >= 4 )
        {
          v37 = v4[10];
          v38 = *((_QWORD *)v4 + 3);
          LOBYTE(v38) = *((_BYTE *)v4 + 1);
          LOBYTE(v37) = *(_BYTE *)v4;
          v39 = sub_1161C(
                  v37,
                  v38,
                  *((unsigned __int8 *)v4 + 2),
                  v4[16],
                  *((_QWORD *)v4 + 3),
                  v4[10],
                  *((_BYTE *)v4 + 3),
                  0,
                  0,
                  *((_DWORD *)v4 + 2),
                  *((unsigned __int8 *)v4 + 4),
                  *((unsigned __int8 *)v4 + 12));
          if ( v39 == -1 )
          {
            v3 = -1073741823;
          }
          else
          {
            *(_DWORD *)v4 = v39;
            *(_QWORD *)(a2 + 56) = 4i64;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002030:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETCHANNEL\n");
        sub_110AC(
          5i64,
          "BUS =%x DEV = %x FN = %x\n",
          *(unsigned __int8 *)v4,
          *((unsigned __int8 *)v4 + 1),
          *((unsigned __int8 *)v4 + 2));
        LODWORD(Irpc) = *((_DWORD *)v4 + 2);
        sub_110AC(
          5i64,
          "MutexType =%x AddrRegOffset = %x AddrRegValue = %x\n",
          *((unsigned __int8 *)v4 + 3),
          *((unsigned __int8 *)v4 + 4),
          Irpc);
        LODWORD(Irpd) = v4[10];
        sub_110AC(
          5i64,
          "DataRegOffset =%x DataRegValue = %x WaitTime = %x\n",
          *((unsigned __int8 *)v4 + 12),
          *((unsigned int *)v4 + 4),
          Irpd);
        if ( v5 == 40 )
        {
          v35 = *((_DWORD *)v4 + 4);
          v36 = v4[10];
          LOBYTE(v35) = *((_BYTE *)v4 + 2);
          LOBYTE(v36) = *((_BYTE *)v4 + 1);
          LOBYTE(v34) = *(_BYTE *)v4;
          v3 = sub_1187C(
                 v34,
                 v36,
                 v35,
                 v4[16],
                 *((_QWORD *)v4 + 3),
                 v4[10],
                 *((_BYTE *)v4 + 3),
                 0,
                 0,
                 *((_DWORD *)v4 + 2),
                 *((unsigned __int8 *)v4 + 4),
                 *((_DWORD *)v4 + 4),
                 *((unsigned __int8 *)v4 + 12));
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002034:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_INFORM_FP_FW_S3S4S5\n");
        sub_110AC(
          5i64,
          "BUS =%x DEV = %x FN = %x\n",
          *(unsigned __int8 *)v4,
          *((unsigned __int8 *)v4 + 1),
          *((unsigned __int8 *)v4 + 2));
        LODWORD(Irpa) = *((_DWORD *)v4 + 2);
        sub_110AC(
          5i64,
          "MutexType =%x AddrRegOffset = %x AddrRegValue = %x\n",
          *((unsigned __int8 *)v4 + 3),
          *((unsigned __int8 *)v4 + 4),
          Irpa);
        LODWORD(Irpb) = v4[10];
        sub_110AC(
          5i64,
          "DataRegOffset =%x DataRegValue = %x WaitTime = %x\n",
          *((unsigned __int8 *)v4 + 12),
          *((unsigned int *)v4 + 4),
          Irpb);
        sub_110AC(5i64, "PCIEBASE =%p IOBASE = %x \n", *((const void **)v4 + 3), v4[16]);
        byte_17161 = 0;
        word_17164 = 0;
        Src = 0;
        dword_1716C = 0;
        if ( v5 == 40 )
        {
          memmove(&byte_17180, v4, 0x28ui64);
          v32 = sub_11B58(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 4u, 1u);
          sub_11CE4(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 4u, v32 | 7, 1u);
          v33 = sub_11B58(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 0x44u, 1u);
          sub_11CE4(byte_17180, byte_17181, byte_17182, *(__int64 *)&qword_17198, 0x44u, v33 & 0xFC, 1u);
          sub_128E8();
          byte_17160 = 1;
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      default:
        goto LABEL_92;
    }
  }
  else
  {
    switch ( (_DWORD)v6 )
    {
      case 0x8000201C:
        sub_110AC(5i64, "IOCTL_ENUM_RTKNIC\n");
        LOWORD(PhysicalAddress.LowPart) = 0;
        do
        {
          LOBYTE(v24) = 0;
          v61 = 0;
          do
          {
            v60 = (unsigned __int8)v24;
            LOBYTE(v23) = 12;
            LOBYTE(LowPart_low) = v3;
            v25 = sub_143D6(LowPart_low, (unsigned __int8)v24, 0i64, v23);
            if ( v25 == -1 || (v25 & 0x800000) == 0 )
              v63 = 1;
            else
              v63 = 8;
            LOBYTE(v26) = 0;
            LOBYTE(BaseAddress) = 0;
            while ( 1 )
            {
              LOBYTE(v27) = v26;
              LOBYTE(v26) = v3;
              v28 = sub_143D6(v26, v60, v27, 0i64);
              if ( v28 == -2127163156
                || v28 == -2127097620
                || v28 == -2123951892
                || v28 == -2123886356
                || v28 == -2123820820
                || v28 == -2124017428
                || v28 == -2124345108 )
              {
                break;
              }
              LOBYTE(v26) = (_BYTE)BaseAddress + 1;
              LOBYTE(BaseAddress) = v26;
              if ( (unsigned __int8)v26 >= (unsigned __int16)v63 )
              {
                LowPart_low = LOWORD(PhysicalAddress.LowPart);
                goto LABEL_82;
              }
            }
            LOBYTE(v23) = 16;
            LOBYTE(v27) = (_BYTE)BaseAddress;
            LOBYTE(v26) = v3;
            v29 = sub_143D6(v26, v60, v27, v23);
            sub_110AC(5i64, "Hardware ID: 0x%08X\n", v29);
            v30 = LOWORD(PhysicalAddress.LowPart);
            *(_DWORD *)&v4[2 * LOWORD(PhysicalAddress.LowPart) + 2] = v29 - 1;
            sub_110AC(5i64, "cnt=%d\n", v30);
            LOWORD(LowPart_low) = ++LOWORD(PhysicalAddress.LowPart);
LABEL_82:
            v24 = v61 + 1;
            v61 = v24;
          }
          while ( v24 < 0x20u );
          LOWORD(v3) = v3 + 1;
        }
        while ( (unsigned __int16)v3 < 0x100u );
        *(_DWORD *)v4 = (unsigned __int16)LowPart_low;
        *(_QWORD *)(a2 + 56) = 4i64 * ((unsigned __int16)LowPart_low + 1);
        sub_110AC(5i64, "pSysBuf:");
        v31 = 10i64;
        v3 = 0;
        do
        {
          sub_110AC(5i64, (const char *)qword_14DE0, *(unsigned int *)v4);
          v4 += 2;
          --v31;
        }
        while ( v31 );
        sub_110AC(5i64, (const char *)qword_14DF0);
        break;
      case 0x80002000:// map primitive 
        sub_110AC(5i64, "!!IOCTL_PHYMEM_MAP\n");
        if ( v5 != 16 || (_DWORD)BaseAddress != 8 )
        {
          v3 = -1073741811;
          break;
        }
        PhysicalAddress.QuadPart = 0i64;
        BaseAddress = 0i64;
        v18 = 0i64;
        v16 = 0i64;
        memmove(&PhysicalAddress, v4, 8ui64);
        v19 = MmMapIoSpace(PhysicalAddress, *((unsigned int *)v4 + 2), MmNonCached);
        v62 = v19;
        if ( v19 )
        {
          Mdl = IoAllocateMdl(v19, *((_DWORD *)v4 + 2), 0, 0, 0i64);
          v18 = Mdl;
          if ( Mdl )
          {
            MmBuildMdlForNonPagedPool(Mdl);
            BaseAddress = MmMapLockedPagesSpecifyCache(v18, 1, MmNonCached, 0i64, 0, 0x10u);
            if ( BaseAddress )
            {
              PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(NonPagedPool, 0x28ui64, 0x6F697452u);
              v16 = PoolWithTag;
              if ( PoolWithTag )
              {
                *((_QWORD *)PoolWithTag + 1) = v18;
                *((_QWORD *)PoolWithTag + 2) = v62;
                *((_QWORD *)PoolWithTag + 3) = BaseAddress;
                PoolWithTag[8] = *((_DWORD *)v4 + 2);
                *(_QWORD *)PoolWithTag = P;
                P = PoolWithTag;
                LODWORD(Irp) = *((_DWORD *)v4 + 2);
                sub_110AC(5i64, "Map physical 0x%p to virtual 0x%p, size %u", *(const void **)v4, BaseAddress, Irp);
                memmove(v4, &BaseAddress, 8ui64);
                *(_QWORD *)(a2 + 56) = 8i64;
              }
              else
              {
                sub_110AC(5i64, "Call to ExAllocatePoolWithTag MAPINFO failed\n");
                v3 = -1073741670;
              }
            }
            else
            {
              sub_110AC(5i64, "Call to MmMapLockedPagesSpecifyCache MAPINFO failed\n");
              v3 = -1073741670;
            }
          }
          else
          {
            v3 = -1073741670;
          }
        }
        else
        {
          v3 = -1073741670;
        }
        if ( v3 )
        {
          if ( BaseAddress )
            MmUnmapLockedPages(BaseAddress, v18);
          if ( v18 )
            IoFreeMdl(v18);
          if ( v62 )
            MmUnmapIoSpace(v62, *((unsigned int *)v4 + 2));
          if ( v16 )
            goto LABEL_63;
        }
        break;
      case 0x80002004:
        sub_110AC(5i64, "!!IOCTL_PHYMEM_UNMAP\n");
        if ( v5 != 16 )
        {
          v3 = -1073741811;
          break;
        }
        v16 = (unsigned int *)P;
        v17 = P;
        if ( P )
        {
          while ( *((_QWORD *)v16 + 3) != *(_QWORD *)v4 )
          {
            v17 = v16;
            v16 = *(unsigned int **)v16;
            if ( !v16 )
              goto LABEL_120;
          }
          if ( v16[8] != *((_DWORD *)v4 + 2) )
          {
            v3 = -1073741811;
            break;
          }
          MmUnmapLockedPages(*((PVOID *)v16 + 3), *((PMDL *)v16 + 1));
          IoFreeMdl(*((PMDL *)v16 + 1));
          MmUnmapIoSpace(*((PVOID *)v16 + 2), v16[8]);
          if ( v16 == P )
            P = *(PVOID *)v16;
          else
            *v17 = *(_QWORD *)v16;
LABEL_63:
          ExFreePoolWithTag(v16, 0);
        }
        break;
      case 0x80002008:// in primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETPORT\n");
        sub_110AC(5i64, "pPort->dwPort=%x\n", *(unsigned int *)v4);
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              v13 = __inbyte(*(_DWORD *)v4);
              *(_DWORD *)v4 = v13;
              break;
            case 2:
              v14 = __inword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v14;
              break;
            case 4:
              v15 = __indword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v15;
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x8000200C://out primitive 
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETPORT");
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              __outbyte(*(_DWORD *)v4, *((_BYTE *)v4 + 8));
              break;
            case 2:
              __outword(*(_DWORD *)v4, v4[4]);
              break;
            case 4:
              __outdword(*(_DWORD *)v4, *((_DWORD *)v4 + 2));
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
      case 0x80002018:
        *(_QWORD *)(a2 + 56) = 8i64;
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SENDSMI");
        v7 = *v4;
        v8 = *((_BYTE *)v4 + 2);
        v9 = v4[2];
        sub_110AC(5i64, "!!!!!!SmiPort=0x%x SmiCommand=0x%x SmiSubCommand=0x%x!!\n", *v4, v8, v9);
        ActiveProcessors = KeQueryActiveProcessors();
        sub_110AC(5i64, "KeActiveProcessors=0x%zx", ActiveProcessors);
        KeSetSystemAffinityThread(1ui64);
        LOBYTE(v11) = v8;
        v12 = (unsigned __int16)sub_143A0(v7, v11, v9);
        KeSetSystemAffinityThread(1ui64);
        sub_110AC(5i64, "SmiResult=%d\n", (unsigned int)v12);
        *(_QWORD *)v4 = v12;
        break;
      default:
LABEL_92:
        if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject
          && (BYTE4(DeviceObject->Timer) & 1) != 0
          && BYTE1(DeviceObject->Timer) >= 4u )
        {
          sub_11008(DeviceObject->AttachedDevice, 43i64, &unk_16150, v6);
        }
        v3 = -1073741808;
        break;
    }
  }
LABEL_120:
  *(_DWORD *)(a2 + 48) = v3;
  IofCompleteRequest((PIRP)a2, 0);
  if ( DeviceObject != (PDEVICE_OBJECT)&DeviceObject
    && (BYTE4(DeviceObject->Timer) & 1) != 0
    && BYTE1(DeviceObject->Timer) >= 4u )
  {
    sub_11008(DeviceObject->AttachedDevice, 44i64, &unk_16150, v3);
  }
  return v3;
}
~~~

### IOCTL  0x80002000

This IOCTL code triggers memory map operation as blow.

~~~c
      case 0x80002000:// map primitive 
        sub_110AC(5i64, "!!IOCTL_PHYMEM_MAP\n");
        if ( v5 != 16 || (_DWORD)BaseAddress != 8 )
        {
          v3 = -1073741811;
          break;
        }
        PhysicalAddress.QuadPart = 0i64;
        BaseAddress = 0i64;
        v18 = 0i64;
        v16 = 0i64;
        memmove(&PhysicalAddress, v4, 8ui64);
        v19 = MmMapIoSpace(PhysicalAddress, *((unsigned int *)v4 + 2), MmNonCached);
        v62 = v19;
        if ( v19 )
        {
          Mdl = IoAllocateMdl(v19, *((_DWORD *)v4 + 2), 0, 0, 0i64);
          v18 = Mdl;
          if ( Mdl )
          {
            MmBuildMdlForNonPagedPool(Mdl);
            BaseAddress = MmMapLockedPagesSpecifyCache(v18, 1, MmNonCached, 0i64, 0, 0x10u);
            if ( BaseAddress )
            {
              PoolWithTag = (unsigned int *)ExAllocatePoolWithTag(NonPagedPool, 0x28ui64, 0x6F697452u);
              v16 = PoolWithTag;
              if ( PoolWithTag )
              {
                *((_QWORD *)PoolWithTag + 1) = v18;
                *((_QWORD *)PoolWithTag + 2) = v62;
                *((_QWORD *)PoolWithTag + 3) = BaseAddress;
                PoolWithTag[8] = *((_DWORD *)v4 + 2);
                *(_QWORD *)PoolWithTag = P;
                P = PoolWithTag;
                LODWORD(Irp) = *((_DWORD *)v4 + 2);
                sub_110AC(5i64, "Map physical 0x%p to virtual 0x%p, size %u", *(const void **)v4, BaseAddress, Irp);
                memmove(v4, &BaseAddress, 8ui64);
                *(_QWORD *)(a2 + 56) = 8i64;
              }
              else
              {
                sub_110AC(5i64, "Call to ExAllocatePoolWithTag MAPINFO failed\n");
                v3 = -1073741670;
              }
            }
            else
            {
              sub_110AC(5i64, "Call to MmMapLockedPagesSpecifyCache MAPINFO failed\n");
              v3 = -1073741670;
            }
          }
          else
          {
            v3 = -1073741670;
          }
        }
        else
        {
          v3 = -1073741670;
        }
        if ( v3 )
        {
          if ( BaseAddress )
            MmUnmapLockedPages(BaseAddress, v18);
          if ( v18 )
            IoFreeMdl(v18);
          if ( v62 )
            MmUnmapIoSpace(v62, *((unsigned int *)v4 + 2));
          if ( v16 )
            goto LABEL_63;
        }
        break;
~~~



### IOCTL  0x8000200C

This IOCTL code triggers port out operation . 

```c
      case 0x8000200C://out primitive 
        sub_110AC(5i64, "!!IOCTL_PHYMEM_SETPORT");
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              __outbyte(*(_DWORD *)v4, *((_BYTE *)v4 + 8));
              break;
            case 2:
              __outword(*(_DWORD *)v4, v4[4]);
              break;
            case 4:
              __outdword(*(_DWORD *)v4, *((_DWORD *)v4 + 2));
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
```

### IOCTL  0x8000200C

This IOCTL code triggers port in operation . 

```c
      case 0x80002008:// in primitive
        sub_110AC(5i64, "!!IOCTL_PHYMEM_GETPORT\n");
        sub_110AC(5i64, "pPort->dwPort=%x\n", *(unsigned int *)v4);
        if ( v5 == 12 )
        {
          *(_QWORD *)(a2 + 56) = 4i64;
          switch ( *((_DWORD *)v4 + 1) )
          {
            case 1:
              v13 = __inbyte(*(_DWORD *)v4);
              *(_DWORD *)v4 = v13;
              break;
            case 2:
              v14 = __inword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v14;
              break;
            case 4:
              v15 = __indword(*(_DWORD *)v4);
              *(_DWORD *)v4 = v15;
              break;
            default:
              v3 = -1073741811;
              break;
          }
        }
        else
        {
          v3 = -1073741811;
        }
        break;
```

