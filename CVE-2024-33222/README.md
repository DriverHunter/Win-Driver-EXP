# Vulnerable Driver ATSZIO64.sys in ASUS ATSZIO Driver v0.2.1.7

---

ATSZIO64.sys in ASUS ATSZIO Driver 0.2.1.7 exposes functionality that allows low-privileged users to map arbitrary physical memory, read and write arbitary i/o port and interact MSR via specially crafted IOCTL requests. This can be exploited for privilege escalation, code execution under high privileges, and information disclosure. These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.  

## version

0.2.1.7

## Vulnerability causes

ATSZIO64.sys provides the functionality of mapping physical memory, read/write I/O ports and MSR interaction, but it does not restrict the privileges of the caller, resulting in low-privileged users being able to call the driver and execute corresponding functions through DeviceIoControl.

~~~c
__int64 __fastcall ioctler(_DRIVER_OBJECT *driver_object, _IRP *a2)
{
  int v3; // ebx
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rax
  unsigned int LowPart; // edx
  ULONG_PTR length; // r14
  ULONG_PTR Length; // r15
  PWSTR Buffer; // rsi
  struct _IRP *v9; // r9
  unsigned __int8 v10; // al
  struct _IRP *v11; // rcx
  char v12; // al
  unsigned __int8 v13; // al
  unsigned __int16 v14; // dx
  unsigned int MdlAddress_high; // eax
  unsigned __int16 v16; // dx
  struct _IRP *v17; // rcx
  char v18; // al
  unsigned __int32 v19; // eax
  unsigned __int32 v20; // eax
  unsigned __int16 MdlAddress; // dx
  struct _IRP *v22; // rcx
  char v23; // dl
  char Type; // al
  unsigned __int32 v25; // eax
  struct _IRP *v26; // r9
  PVOID inputbuffer; // rsi
  unsigned __int16 v28; // r15
  NTSTATUS v29; // eax
  _BYTE *mapped_virtual_addr_1; // rdx
  char v31; // al
  struct _IRP *v32; // rsi
  unsigned __int16 v33; // r15
  char v34; // al
  struct _IRP *v35; // r9
  unsigned __int16 v36; // cx
  _BYTE *v37; // r10
  unsigned __int8 v38; // al
  struct _IRP *v39; // rcx
  unsigned __int16 v40; // dx
  _BYTE *v41; // r9
  unsigned __int8 v42; // al
  struct _IRP *v43; // rcx
  unsigned __int16 v44; // dx
  _DWORD *v45; // r8
  unsigned __int32 v46; // eax
  PVOID inputbuffer_1; // rsi
  __int64 v48; // r12
  _BYTE *mapped_virtual_addr_2; // rcx
  signed __int64 v50; // rsi
  struct _IRP *v51; // r14
  ULONG BusDataByOffset; // eax
  int v53; // r9d
  char v54; // al
  struct _IRP *v55; // rsi
  struct _LIST_ENTRY *ContiguousMemory; // r14
  struct _IRP *v57; // r14
  ULONG v58; // edx
  ULONG v59; // ecx
  char v60; // al
  int Flags_low; // eax
  __int64 v62; // r8
  struct _IRP *v63; // rcx
  __int64 v64; // r8
  struct _IRP *v65; // rcx
  char v66; // dl
  PVOID inputbuffer_2; // rsi
  unsigned int Status; // ebx
  __int128 v70; // [rsp+30h] [rbp-48h] BYREF
  __int64 v71; // [rsp+40h] [rbp-38h]
  int v72; // [rsp+48h] [rbp-30h]
  PVOID mapped_virtual_addr; // [rsp+80h] [rbp+8h] BYREF
  PHANDLE physical_memory_handle; // [rsp+88h] [rbp+10h] BYREF

  physical_memory_handle = (PHANDLE)a2;
  v3 = 0;
  a2->IoStatus.Status = 0;
  a2->IoStatus.Information = 0i64;
  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  LowPart = CurrentStackLocation->Parameters.Read.ByteOffset.LowPart;
  length = CurrentStackLocation->Parameters.Create.Options;
  Length = CurrentStackLocation->Parameters.Read.Length;
  Buffer = driver_object->DriverName.Buffer;
  if ( LowPart <= 0x88070F84 )
  {
    if ( LowPart == 0x88070F84 )
    {
      inputbuffer_1 = a2->AssociatedIrp.MasterIrp;
      *((_QWORD *)inputbuffer_1 + 4) = 0i64;
      if ( !(_DWORD)length )
        goto LABEL_140;
      v48 = 4096i64;
      v29 = call_ZwMapOfSection(
              (union _LARGE_INTEGER)(*((_QWORD *)inputbuffer_1 + 3) & 0xFFFFFFFFFFFFF000ui64),
              0x1000u,
              &mapped_virtual_addr,
              (PHANDLE)&physical_memory_handle);
      mapped_virtual_addr_1 = mapped_virtual_addr;
      *((_QWORD *)inputbuffer_1 + 4) = mapped_virtual_addr;
      *((_QWORD *)inputbuffer_1 + 1) = physical_memory_handle;
      if ( v29 < 0 )
        goto LABEL_137;
      mapped_virtual_addr_2 = mapped_virtual_addr_1;
      v50 = (_BYTE *)inputbuffer_1 - mapped_virtual_addr_1;// ?! here can cause BSOD
      do
      {
        mapped_virtual_addr_2[v50 + 40] = *mapped_virtual_addr_2;
        ++mapped_virtual_addr_2;
        --v48;
      }
      while ( v48 );
    }
    else
    {
      if ( LowPart <= 0x88070F6C )
      {
        switch ( LowPart )
        {
          case 0x88070F6C:
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
            v26 = a2->AssociatedIrp.MasterIrp;
            if ( LOBYTE(v26->Type) != 1 )
              goto LABEL_130;
            __outbyte((unsigned __int16)v26->MdlAddress, BYTE2(v26->MdlAddress));
            v13 = BYTE2(v26->Flags);
            v14 = LOWORD(v26->MdlAddress) + 1;
            goto LABEL_14;
          case 0x88070F58:
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
            v17 = a2->AssociatedIrp.MasterIrp;
            __outdword(0xCF8u, *(_DWORD *)(&v17->Size + 1));
            Type = v17->Type;
            if ( LOBYTE(v17->Type) == 1 )
            {
              v19 = __indword(0xCFCu);
              goto LABEL_35;
            }
            if ( Type == 2 )
            {
              v20 = __indword(0xCFCu);
              goto LABEL_38;
            }
            if ( Type != 4 )
              goto LABEL_130;
            MdlAddress = 3324;
            break;
          case 0x88070F5C:
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
            v22 = a2->AssociatedIrp.MasterIrp;
            __outdword(0xCF8u, *(_DWORD *)(&v22->Size + 1));
            __indword(0xCFCu);
            v23 = v22->Type;
            if ( LOBYTE(v22->Type) == 1 )
            {
              MdlAddress_high = 0;
            }
            else if ( v23 == 2 )
            {
              MdlAddress_high = 0;
            }
            else
            {
              if ( v23 != 4 )
                goto LABEL_130;
              MdlAddress_high = HIDWORD(v22->MdlAddress);
            }
            v16 = 3324;
            goto LABEL_32;
          case 0x88070F60: // in primitive
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
            v17 = a2->AssociatedIrp.MasterIrp;
            v18 = v17->Type;
            if ( LOBYTE(v17->Type) == 1 )
            {
              LOBYTE(v19) = __inbyte((unsigned __int16)v17->MdlAddress);
LABEL_35:
              BYTE2(v17->Flags) = v19;
              goto LABEL_42;
            }
            if ( v18 == 2 )
            {
              LOWORD(v20) = __inword((unsigned __int16)v17->MdlAddress);
LABEL_38:
              LOWORD(v17->Flags) = v20;
              goto LABEL_42;
            }
            if ( v18 != 4 )
              goto LABEL_130;
            MdlAddress = (unsigned __int16)v17->MdlAddress;
            break;
          case 0x88070F64:// out primitive
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
            v11 = a2->AssociatedIrp.MasterIrp;
            v12 = v11->Type;
            if ( LOBYTE(v11->Type) == 1 )
            {
              v13 = BYTE2(v11->Flags);
              v14 = (unsigned __int16)v11->MdlAddress;
LABEL_14:
              __outbyte(v14, v13);
LABEL_131:
              KeSetEvent(*((PRKEVENT *)Buffer + 5), 0, 0);
              goto LABEL_141;
            }
            if ( v12 == 2 )
            {
              __outword((unsigned __int16)v11->MdlAddress, v11->Flags);
              goto LABEL_131;
            }
            if ( v12 != 4 )
              goto LABEL_130;
            MdlAddress_high = HIDWORD(v11->MdlAddress);
            v16 = (unsigned __int16)v11->MdlAddress;
LABEL_32:
            __outdword(v16, MdlAddress_high);
            goto LABEL_131;
          case 0x88070F68:
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
            v9 = a2->AssociatedIrp.MasterIrp;
            if ( LOBYTE(v9->Type) == 1 )
            {
              __outbyte((unsigned __int16)v9->MdlAddress, BYTE2(v9->MdlAddress));
              v10 = __inbyte(LOWORD(v9->MdlAddress) + 1);
              BYTE2(v9->Flags) = v10;
LABEL_42:
              a2->IoStatus.Information = 20i64;
              goto LABEL_131;
            }
LABEL_130:
            a2->IoStatus.Status = -1073741811;
            goto LABEL_131;
          default:
LABEL_140:
            a2->IoStatus.Status = 0xC000000D;
            goto LABEL_141;
        }
        v25 = __indword(MdlAddress);
        HIDWORD(v17->MdlAddress) = v25;
        goto LABEL_42;
      }
      switch ( LowPart )
      {
        case 0x88070F70:
          KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
          v43 = a2->AssociatedIrp.MasterIrp;
          v44 = (unsigned __int16)v43->MdlAddress;
          if ( v44 <= 0x200u )
          {
            if ( v44 )
            {
              v45 = (_DWORD *)((char *)&v43->MdlAddress + 2);
              do
              {
                __outdword(0xCF8u, *(_DWORD *)&v43->Type);
                v46 = __indword(0xCFCu);
                *v45 = v46;
                *(_DWORD *)&v43->Type += 4;
                a2->IoStatus.Information = 524i64;
                v3 += 4;
                ++v45;
              }
              while ( v3 < LOWORD(v43->MdlAddress) );
            }
            goto LABEL_131;
          }
          goto LABEL_130;
        case 0x88070F74:
          KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
          v39 = a2->AssociatedIrp.MasterIrp;
          v40 = (unsigned __int16)v39->MdlAddress;
          if ( v40 <= 0x200u )
          {
            if ( v40 )
            {
              v41 = (char *)&v39->MdlAddress + 2;
              do
              {
                v42 = __inbyte(*(&v39->Size + 1));
                *v41 = v42;
                ++*(&v39->Size + 1);
                a2->IoStatus.Information = 524i64;
                ++v3;
                ++v41;
              }
              while ( v3 < LOWORD(v39->MdlAddress) );
            }
            goto LABEL_131;
          }
          goto LABEL_130;
        case 0x88070F78:
          KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
          v35 = a2->AssociatedIrp.MasterIrp;
          v36 = (unsigned __int16)v35->MdlAddress;
          if ( v36 <= 0x200u && v36 )
          {
            v37 = (char *)&v35->MdlAddress + 2;
            do
            {
              __outbyte(*(&v35->Size + 1), *((_BYTE *)&v35->Size + 4));
              v38 = __inbyte(*(&v35->Size + 1) + 1);
              *v37 = v38;
              ++*((_BYTE *)&v35->Size + 4);
              a2->IoStatus.Information = 524i64;
              ++v3;
              ++v37;
            }
            while ( v3 < LOWORD(v35->MdlAddress) );
          }
          goto LABEL_131;
      }
      if ( LowPart != 0x88070F7C )
      {
        if ( LowPart != 0x88070F80 )
          goto LABEL_140;
        inputbuffer = a2->AssociatedIrp.MasterIrp;
        v28 = *((_WORD *)inputbuffer + 12) & 0xFFF;
        *((_QWORD *)inputbuffer + 4) = 0i64;
        if ( !(_DWORD)length )
          goto LABEL_140;
        v29 = call_ZwMapOfSection(              // write arbitrary physical memory IOCTL_CODE = 0x88070f80
                (union _LARGE_INTEGER)(*((_QWORD *)inputbuffer + 3) & 0xFFFFFFFFFFFFF000ui64),
                *((_DWORD *)inputbuffer + 4),
                &mapped_virtual_addr,
                (PHANDLE)&physical_memory_handle);
        mapped_virtual_addr_1 = mapped_virtual_addr;
        *((_QWORD *)inputbuffer + 4) = mapped_virtual_addr;
        *((_QWORD *)inputbuffer + 1) = physical_memory_handle;
        if ( v29 >= 0 )
        {
          v31 = *(_BYTE *)inputbuffer;
          if ( *(_BYTE *)inputbuffer == 1 )     // write byte
          {
            mapped_virtual_addr_1[v28] = *((_BYTE *)inputbuffer + 1);
          }
          else if ( v31 == 2 )                  // write word
          {
            if ( v28 > 0xFFEu )
              goto LABEL_140;
            *(_WORD *)&mapped_virtual_addr_1[v28] = *((_WORD *)inputbuffer + 1);
          }
          else                                  // write dword
          {
            if ( v31 != 4 || v28 > 0xFFCu )
              goto LABEL_140;
            *(_DWORD *)&mapped_virtual_addr_1[v28] = *((_DWORD *)inputbuffer + 1);
          }
          goto LABEL_60;
        }
LABEL_137:
        a2->IoStatus.Status = v29;
        goto LABEL_141;
      }
      v32 = a2->AssociatedIrp.MasterIrp;
      v33 = (__int64)v32->AssociatedIrp.MasterIrp & 0xFFF;
      v32->ThreadListEntry.Flink = 0i64;
      if ( !(_DWORD)length )
        goto LABEL_140;
      v29 = call_ZwMapOfSection(
              (union _LARGE_INTEGER)((unsigned __int64)v32->AssociatedIrp.MasterIrp & 0xFFFFFFFFFFFFF000ui64),
              0x1000u,
              &mapped_virtual_addr,
              (PHANDLE)&physical_memory_handle);
      v32->MdlAddress = (PMDL)physical_memory_handle;
      mapped_virtual_addr_1 = mapped_virtual_addr;
      v32->ThreadListEntry.Flink = (struct _LIST_ENTRY *)mapped_virtual_addr;
      if ( v29 < 0 )
        goto LABEL_137;
      v34 = v32->Type;
      if ( LOBYTE(v32->Type) == 1 )
      {
        HIBYTE(v32->Type) = mapped_virtual_addr_1[v33];
      }
      else if ( v34 == 2 )
      {
        if ( v33 > 0xFFEu )
          goto LABEL_140;
        v32->Size = *(_WORD *)&mapped_virtual_addr_1[v33];
      }
      else
      {
        if ( v34 != 4 || v33 > 0xFFCu )
          goto LABEL_140;
        *(_DWORD *)(&v32->Size + 1) = *(_DWORD *)&mapped_virtual_addr_1[v33];
      }
    }
LABEL_60:
    a2->IoStatus.Information = length;
    v29 = call_ZwUnMapViewOfSection(physical_memory_handle, mapped_virtual_addr_1);
    goto LABEL_137;
  }
  if ( LowPart > 0x88072004 )
  {
    if ( LowPart == 0x8807200C )
    {
      inputbuffer_2 = a2->AssociatedIrp.MasterIrp;
      *((_QWORD *)inputbuffer_2 + 4) = 0i64;
      if ( (_DWORD)length )
      {
        call_ZwMapOfSection(                    // mapping physical memory
          (union _LARGE_INTEGER)(*((_QWORD *)inputbuffer_2 + 3) & 0xFFFFFFFFFFFFF000ui64),
          *((_DWORD *)inputbuffer_2 + 4),
          (PVOID *)&physical_memory_handle,
          &mapped_virtual_addr);
        *((_QWORD *)inputbuffer_2 + 4) = physical_memory_handle;
        *((_QWORD *)inputbuffer_2 + 1) = mapped_virtual_addr;
        a2->IoStatus.Information = Length;
        goto LABEL_141;
      }
      goto LABEL_140;
    }
    if ( LowPart != 0x88072010 )
    {
      if ( LowPart == -2012798956 )
      {
        KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
        v65 = a2->AssociatedIrp.MasterIrp;
        v66 = v65->Type;
        if ( ((LOBYTE(v65->Type) - 1) & 0xFC) == 0 && v66 != 3 && (unsigned int)length >= 0x23 )
        {
          v70 = *(_OWORD *)((char *)&v65->Size + 5);
          v71 = *(_QWORD *)((char *)&v65->Flags + 7);
          v72 = *(_DWORD *)((char *)&v65->AssociatedIrp.SystemBuffer + 7);
          LOBYTE(v64) = v66;
          sub_140001010(
            *(unsigned __int16 *)((char *)&v65->Type + 1),
            *(unsigned int *)((char *)&v65->Size + 1),
            v64,
            &v70);
          goto LABEL_131;
        }
        goto LABEL_130;
      }
      if ( LowPart == -2012798952 )
      {
        KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
        v63 = a2->AssociatedIrp.MasterIrp;
        if ( ((LOBYTE(v63->Type) - 1) & 0xFC) == 0 && LOBYTE(v63->Type) != 3 && (unsigned int)length >= 0x23 )
        {
          LOBYTE(v62) = v63->Type;
          sub_140001100(
            *(unsigned __int16 *)((char *)&v63->Type + 1),
            *(unsigned int *)((char *)&v63->Size + 1),
            v62,
            (char *)&v63->Size + 5);
          a2->IoStatus.Information = 35i64;
          goto LABEL_131;
        }
        goto LABEL_130;
      }
      goto LABEL_140;
    }
    v29 = call_ZwUnMapViewOfSection(
            a2->AssociatedIrp.MasterIrp->MdlAddress,
            a2->AssociatedIrp.MasterIrp->ThreadListEntry.Flink);
    a2->IoStatus.Information = 0i64;
    goto LABEL_137;
  }
  switch ( LowPart )
  {
    case 0x88072004:
      KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
      v57 = a2->AssociatedIrp.MasterIrp;
      LODWORD(physical_memory_handle) = 0;
      v58 = *((unsigned __int8 *)&v57->Size + 4);
      v59 = (unsigned __int8)*(_DWORD *)(&v57->Size + 1);
      v60 = v57->Type;
      if ( LOBYTE(v57->Type) == 1 )
      {
        Flags_low = BYTE2(v57->Flags);
      }
      else if ( v60 == 2 )
      {
        Flags_low = LOWORD(v57->Flags);
      }
      else
      {
        if ( v60 != 4 )
        {
          a2->IoStatus.Status = -1073741811;
LABEL_120:
          if ( HalSetBusDataByOffset(
                 PCIConfiguration,
                 v58,
                 (*(_DWORD *)(&v57->Size + 1) & 0x700 | (*(_DWORD *)(&v57->Size + 1) >> 8) & 0xF8u) >> 3,
                 &physical_memory_handle,
                 v59,
                 LOBYTE(v57->Type)) == LOBYTE(v57->Type) )
            goto LABEL_42;
          goto LABEL_130;
        }
        Flags_low = HIDWORD(v57->MdlAddress);
      }
      LODWORD(physical_memory_handle) = Flags_low;
      goto LABEL_120;
    case 0x88070F88:
      a2->AssociatedIrp.MasterIrp->MdlAddress = (PMDL)__readmsr(*(_DWORD *)a2->AssociatedIrp.MasterIrp);// rdmsr
      a2->IoStatus.Information = 16i64;
      break;
    case 0x88070F8C:
      __writemsr(*(_DWORD *)a2->AssociatedIrp.MasterIrp, (unsigned __int64)a2->AssociatedIrp.MasterIrp->MdlAddress);// wrmsr
      break;
    case 0x88070F90:
      v55 = a2->AssociatedIrp.MasterIrp;
      DbgPrint("XXXXXXXX alloc mem size is 0x%lx bytes !\n", v55->Flags);
      v55->ThreadListEntry.Flink = 0i64;
      ContiguousMemory = (struct _LIST_ENTRY *)MmAllocateContiguousMemory(v55->Flags, (PHYSICAL_ADDRESS)0xFFFFFFFFi64);
      if ( !ContiguousMemory )
        goto LABEL_140;
      DbgPrint("XXXXXXXX address is 0x%lx !\n", v55->AssociatedIrp.MasterIrp);
      v55->AssociatedIrp.MasterIrp = (struct _IRP *)MmGetPhysicalAddress(ContiguousMemory).LowPart;
      v55->ThreadListEntry.Flink = ContiguousMemory;
      a2->IoStatus.Information = 4136i64;
      break;
    case 0x88070F94:
      MmFreeContiguousMemory(a2->AssociatedIrp.MasterIrp->ThreadListEntry.Flink);
      break;
    case 0x88072000:
      KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);
      v51 = a2->AssociatedIrp.MasterIrp;
      LODWORD(physical_memory_handle) = 0;
      BusDataByOffset = HalGetBusDataByOffset(
                          PCIConfiguration,
                          *((unsigned __int8 *)&v51->Size + 4),
                          (*(_DWORD *)(&v51->Size + 1) & 0x700 | (*(_DWORD *)(&v51->Size + 1) >> 8) & 0xF8u) >> 3,
                          &physical_memory_handle,
                          (unsigned __int8)*(_DWORD *)(&v51->Size + 1),
                          LOBYTE(v51->Type));
      v53 = (int)physical_memory_handle;
      if ( BusDataByOffset != LOBYTE(v51->Type) )
        v53 = -1;
      LODWORD(physical_memory_handle) = v53;
      v54 = v51->Type;
      if ( LOBYTE(v51->Type) == 1 )
      {
        BYTE2(v51->Flags) = v53;
      }
      else if ( v54 == 2 )
      {
        LOWORD(v51->Flags) = v53;
      }
      else if ( v54 == 4 )
      {
        HIDWORD(v51->MdlAddress) = v53;
      }
      else
      {
        a2->IoStatus.Status = -1073741811;
      }
      goto LABEL_42;
    default:
      goto LABEL_140;
  }
LABEL_141:
  Status = a2->IoStatus.Status;
  IofCompleteRequest(a2, 0);
  return Status;
}
~~~

### IOCTL  0x88070F60

This IOCTL code triggers port in operation. 

~~~c
   case 0x88070F60:
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);// in primitive
            v17 = a2->AssociatedIrp.MasterIrp;
            v18 = v17->Type;
            if ( LOBYTE(v17->Type) == 1 )
            {
              LOBYTE(v19) = __inbyte((unsigned __int16)v17->MdlAddress);
LABEL_35:
              BYTE2(v17->Flags) = v19;
              goto LABEL_42;
            }
            if ( v18 == 2 )
            {
              LOWORD(v20) = __inword((unsigned __int16)v17->MdlAddress);
LABEL_38:
              LOWORD(v17->Flags) = v20;
              goto LABEL_42;
            }
            if ( v18 != 4 )
              goto LABEL_130;
            MdlAddress = (unsigned __int16)v17->MdlAddress;
            break;
~~~



### IOCTL  0x88070F64

This IOCTL code triggers port out operation . 

~~~c
       case 0x88070F64:
            KeWaitForSingleObject(*((PVOID *)Buffer + 5), Executive, 0, 0, 0i64);// out primitive
            v11 = a2->AssociatedIrp.MasterIrp;
            v12 = v11->Type;
            if ( LOBYTE(v11->Type) == 1 )
            {
              v13 = BYTE2(v11->Flags);
              v14 = (unsigned __int16)v11->MdlAddress;
LABEL_14:
              __outbyte(v14, v13);
LABEL_131:
              KeSetEvent(*((PRKEVENT *)Buffer + 5), 0, 0);
              goto LABEL_141;
            }
            if ( v12 == 2 )
            {
              __outword((unsigned __int16)v11->MdlAddress, v11->Flags);
              goto LABEL_131;
            }
            if ( v12 != 4 )
              goto LABEL_130;
            MdlAddress_high = HIDWORD(v11->MdlAddress);
            v16 = (unsigned __int16)v11->MdlAddress;
LABEL_32:
            __outdword(v16, MdlAddress_high);
            goto LABEL_131;
~~~



### IOCTL  0x8807200C

This IOCTL code triggers memory map operation in function 0x140005B0C . 

~~~c
NTSTATUS __fastcall call_ZwMapOfSection(union _LARGE_INTEGER a1, unsigned int a2, PVOID *a3, PHANDLE a4)
{
  ULONG_PTR v4; // rbx
  NTSTATUS result; // eax
  SIZE_T v9; // r15
  NTSTATUS v10; // eax
  void *v11; // rcx
  NTSTATUS v12; // ebx
  NTSTATUS v13; // ebx
  union _LARGE_INTEGER SectionOffset; // [rsp+58h] [rbp-39h] BYREF
  ULONG_PTR ViewSize; // [rsp+60h] [rbp-31h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+68h] [rbp-29h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+98h] [rbp+7h] BYREF
  PVOID Object; // [rsp+A8h] [rbp+17h] BYREF
  PVOID BaseAddress; // [rsp+F8h] [rbp+67h] BYREF

  v4 = a2;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\PhysicalMemory");
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 512;
  result = ZwOpenSection(a4, 7u, &ObjectAttributes);
  BaseAddress = 0i64;
  v9 = (unsigned int)v4;
  ViewSize = v4;
  SectionOffset = a1;
  if ( result >= 0 )
  {
    v10 = ObReferenceObjectByHandle(*a4, 7u, 0i64, 0, &Object, 0i64);
    v11 = *a4;
    v12 = v10;
    if ( v10 >= 0 )
    {
      v13 = ZwMapViewOfSection(
              v11,                              // rcx
              (HANDLE)0xFFFFFFFFFFFFFFFFi64,    // rdx
              &BaseAddress,                     // r8
              0i64,                             // r9
              v9,                               // rsp+20
              &SectionOffset,                   // rsp+28
              &ViewSize,                        // rsp+30
              ViewShare,                        // rsp+38
              0,
              4u);
      ZwClose(*a4);
      result = v13;
      *a3 = BaseAddress;
      return result;
    }
    ZwClose(v11);
    result = v12;
  }
  *a3 = 0i64;
  return result;
}
~~~

### IOCTL  0x88070F88

This IOCTL code triggers MSR read operation. 

~~~c
    case 0x88070F88:
      a2->AssociatedIrp.MasterIrp->MdlAddress = (PMDL)__readmsr(*(_DWORD *)a2->AssociatedIrp.MasterIrp);// rdmsr
      a2->IoStatus.Information = 16i64;
      break;
~~~

### IOCTL  0x88070F8C

This IOCTL code triggers MSR write operation. 

~~~c
case 0x88070F8C:
    __writemsr(*(_DWORD *)a2->AssociatedIrp.MasterIrp, (unsigned __int64)a2->AssociatedIrp.MasterIrp->MdlAddress);// wrmsr
      break;
~~~

